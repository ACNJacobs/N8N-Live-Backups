{
  "createdAt": "2025-07-22T08:20:42.019Z",
  "updatedAt": "2025-08-15T11:02:18.000Z",
  "id": "zM9trOH14KTomHbp",
  "name": "Subcontract0r review",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "options": {
          "temperature": 0.2
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -192,
        608
      ],
      "id": "66bbab92-c59c-49da-9027-5c4022f72425",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "dob7yodE27d15REW",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// JSON data ophalen uit de vorige node\nconst jsonData = $input.first().json;\n\n/**\n * Helper functie om veilig waarden uit nested objecten te halen\n */\nfunction getValue(obj, path, defaultValue = 'N/A') {\n    try {\n        const value = path.split('.').reduce((acc, key) => acc && acc[key], obj);\n        return value !== undefined && value !== null ? value : defaultValue;\n    } catch {\n        return defaultValue;\n    }\n}\n\n/**\n * Zoekt door alle documenten naar een specifiek veld\n */\nfunction findInAllDocuments(documents, fieldNames) {\n    for (const fieldName of fieldNames) {\n        for (const doc of documents) {\n            if (doc[fieldName] && doc[fieldName] !== 'N/A') {\n                return doc[fieldName];\n            }\n        }\n    }\n    return 'N/A';\n}\n\n/**\n * Extraheert ALLE nuttige data uit het complexe JSON-object - VOLLEDIG DYNAMISCH\n */\nfunction extractAllData(data) {\n    const report = data.full_validation_report?.individual_reports?.[0] || data.full_validation_report || data;\n    const validation = data.full_validation_report?.validation_summary || report.validation_summary || {};\n    const originalDocs = report.original_document_details || {};\n    \n    // Maak een platte lijst van alle documenten voor eenvoudiger zoeken\n    const allDocuments = [];\n    for (const [category, docData] of Object.entries(originalDocs)) {\n        if (docData) {\n            const documents = Array.isArray(docData) ? docData : [docData];\n            documents.forEach(doc => {\n                if (doc) {\n                    allDocuments.push({ category, ...doc });\n                }\n            });\n        }\n    }\n    \n    const extractedData = {};\n    \n    // === ALGEMENE STATUS ===\n    extractedData['Decision'] = data.decision || 'UNKNOWN';\n    extractedData['Overall_Status'] = data.overall_status || validation.overall_status || 'UNKNOWN';\n    extractedData['Validation_Date'] = validation.validation_date || new Date().toLocaleDateString('en-US');\n    extractedData['Total_Documents_Processed'] = data.total_documents_processed || validation.documents_processed || allDocuments.length;\n    \n    // === WORKER INFORMATIE - DYNAMISCH ===\n    extractedData['Worker_Name'] = findInAllDocuments(allDocuments, ['worker_name', 'holder_name', 'employee_name']) ||\n                                   (allDocuments.find(d => d.given_names && d.surname) ? \n                                    `${allDocuments.find(d => d.given_names).given_names} ${allDocuments.find(d => d.surname).surname}`.trim() : 'N/A');\n    \n    // Special handling for birth date - show all if there's a mismatch\n    const personalDataComp = report.personal_data_comparison || {};\n    if (personalDataComp.birth_date && personalDataComp.birth_date.status === 'MISMATCH') {\n        const birthDates = [];\n        if (personalDataComp.birth_date.social_security_doc && personalDataComp.birth_date.social_security_doc !== 'N/A') {\n            birthDates.push(`A1: ${personalDataComp.birth_date.social_security_doc}`);\n        }\n        if (personalDataComp.birth_date.identity_doc && personalDataComp.birth_date.identity_doc !== 'N/A') {\n            birthDates.push(`ID: ${personalDataComp.birth_date.identity_doc}`);\n        }\n        if (personalDataComp.birth_date.work_notification && personalDataComp.birth_date.work_notification !== 'N/A') {\n            birthDates.push(`Work: ${personalDataComp.birth_date.work_notification}`);\n        }\n        extractedData['Birth_Date'] = birthDates.length > 0 ? birthDates.join(' | ') : 'N/A';\n        extractedData['Birth_Date_Status'] = 'MISMATCH';\n    } else {\n        extractedData['Birth_Date'] = findInAllDocuments(allDocuments, ['birth_date']);\n    }\n    \n    // Special handling for names - show all if there's a mismatch  \n    if (personalDataComp.name && personalDataComp.name.status === 'MISMATCH') {\n        const names = [];\n        if (personalDataComp.name.social_security_doc && personalDataComp.name.social_security_doc !== 'N/A') {\n            names.push(`A1: ${personalDataComp.name.social_security_doc}`);\n        }\n        if (personalDataComp.name.identity_doc && personalDataComp.name.identity_doc !== 'N/A') {\n            names.push(`ID: ${personalDataComp.name.identity_doc}`);\n        }\n        if (personalDataComp.name.work_notification && personalDataComp.name.work_notification !== 'N/A') {\n            names.push(`Work: ${personalDataComp.name.work_notification}`);\n        }\n        extractedData['All_Names_Found'] = names.length > 0 ? names.join(' | ') : 'N/A';\n        extractedData['Name_Status'] = 'MISMATCH';\n    }\n    \n    extractedData['Personal_ID'] = findInAllDocuments(allDocuments, ['personal_identifier', 'employee_identification']);\n    extractedData['Nationality'] = findInAllDocuments(allDocuments, ['nationality']) || validation.worker_nationality || 'N/A';\n    extractedData['Gender'] = findInAllDocuments(allDocuments, ['gender']);\n    extractedData['Profession'] = findInAllDocuments(allDocuments, ['profession', 'sector']);\n    \n    // === DOCUMENT STATUS - ALLE MOGELIJKE DOCUMENTEN ===\n    const mandatoryDocs = report.mandatory_documents_check || {};\n    const documentStatusFields = [\n        'social_security_document_present',\n        'identity_document_present', \n        'work_notification_present',\n        'safety_certificate_present',\n        'professional_certificate_present',\n        'training_certificate_present',\n        'medical_certificate_present',\n        'all_mandatory_present'\n    ];\n    \n    for (const field of documentStatusFields) {\n        if (mandatoryDocs[field] !== undefined) {\n            const displayName = field.replace(/_present$/, '').replace(/_/g, ' ')\n                                     .replace(/\\b\\w/g, l => l.toUpperCase());\n            extractedData[`${displayName}_Status`] = mandatoryDocs[field];\n        }\n    }\n    \n    // === ALLE DOCUMENT DETAILS - DYNAMISCH ===\n    for (const [category, docData] of Object.entries(originalDocs)) {\n        if (!docData) continue;\n        \n        const documents = Array.isArray(docData) ? docData : [docData];\n        const categoryName = category.replace(/_data$/, '').replace(/_/g, ' ')\n                                    .replace(/\\b\\w/g, l => l.toUpperCase());\n        \n        documents.forEach((doc, index) => {\n            if (!doc || Object.keys(doc).length === 0) return;\n            \n            const prefix = documents.length > 1 ? `${categoryName}_${index + 1}` : categoryName;\n            \n            // VOLLEDIG DYNAMISCHE velden extractie - geen hardcoding meer!\n            const priorityFields = [\n                'document_type', 'certificate_type', 'document_number', 'certificate_number',\n                'given_names', 'surname', 'worker_name', 'holder_name', 'employee_name',\n                'birth_date', 'nationality', 'gender', 'personal_identifier',\n                'work_period_start', 'work_period_end', 'expiry_date', 'issue_date',\n                'employer_name', 'sending_company', 'work_location', 'sector',\n                'issuing_country', 'issuing_authority', 'notification_country'\n            ];\n            \n            // Process priority fields first for better ordering\n            for (const field of priorityFields) {\n                if (doc[field] !== undefined && doc[field] !== null && doc[field] !== '') {\n                    const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                    extractedData[`${prefix}_${displayName}`] = doc[field];\n                }\n            }\n            \n            // Then process ALL remaining fields (truly dynamic!)\n            for (const [field, value] of Object.entries(doc)) {\n                // Skip fields already processed, additional_fields (handled separately), and empty values\n                if (priorityFields.includes(field) || field === 'additional_fields' || \n                    value === undefined || value === null || value === '') {\n                    continue;\n                }\n                \n                let displayValue = value;\n                if (Array.isArray(displayValue)) {\n                    displayValue = displayValue.join(', '); // Direct array formatting instead of formatArray\n                } else if (typeof displayValue === 'object') {\n                    // Skip complex objects\n                    continue;\n                }\n                \n                const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                extractedData[`${prefix}_${displayName}`] = displayValue;\n            }\n            \n            // Special handling for signature and stamp presence (YES/NO only)\n            if (doc.stamp_present !== undefined) {\n                extractedData[`${prefix}_Stamp_Present`] = doc.stamp_present ? 'YES' : 'NO';\n            }\n            if (doc.signature_present !== undefined) {\n                extractedData[`${prefix}_Signature_Present`] = doc.signature_present ? 'YES' : 'NO';\n            }\n            \n            // Additional fields sectie (exclude confidence scores)\n            if (doc.additional_fields && typeof doc.additional_fields === 'object') {\n                for (const [field, value] of Object.entries(doc.additional_fields)) {\n                    // Skip confidence scores, only show presence\n                    if (field.includes('_confidence')) continue;\n                    \n                    if (value !== undefined && value !== null && value !== '') {\n                        let displayValue = value;\n                        \n                        // Convert boolean presence to YES/NO\n                        if (field.includes('_present') || field.includes('stamp_') || field.includes('signature_')) {\n                            if (typeof value === 'boolean') {\n                                displayValue = value ? 'YES' : 'NO';\n                            }\n                        }\n                        \n                        const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                        extractedData[`${prefix}_${displayName}`] = displayValue;\n                    }\n                }\n            }\n        });\n    }\n    \n    // === CONSISTENTIE CHECKS ===\n    const personalComparison = report.personal_data_comparison || {};\n    const consistencyFields = ['name', 'birth_date', 'personal_identifier', 'nationality'];\n    \n    for (const field of consistencyFields) {\n        if (personalComparison[field]?.status) {\n            const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            extractedData[`${displayName}_Consistency`] = personalComparison[field].status;\n            \n            if (personalComparison[field].issues) {\n                extractedData[`${displayName}_Issues`] = personalComparison[field].issues;\n            }\n        }\n    }\n    \n    // === CROSS-DOCUMENT CONSISTENCY ===\n    const crossConsistency = report.cross_document_consistency || {};\n    for (const [field, value] of Object.entries(crossConsistency)) {\n        if (value !== undefined) {\n            const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            extractedData[`Cross_${displayName}`] = value;\n        }\n    }\n    \n    // === DOCUMENT VALIDITY ===\n    const docValidity = report.document_validity_check || {};\n    for (const [field, value] of Object.entries(docValidity)) {\n        if (value !== undefined && value !== 'N/A') {\n            const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            extractedData[`Validity_${displayName}`] = value;\n        }\n    }\n    \n    // === FLAGS & WARNINGS - GEDETAILLEERD ===\n    const flags = report.flags_and_warnings || data.full_validation_report?.flags_and_warnings || [];\n    extractedData['Total_Issues'] = flags.length;\n    extractedData['Critical_Issues_Count'] = flags.filter(f => f.type === 'CRITICAL').length;\n    extractedData['Error_Count'] = flags.filter(f => f.type === 'ERROR').length;\n    extractedData['Warning_Count'] = flags.filter(f => f.type === 'WARNING').length;\n    \n    // Individuele issues (top 5)\n    flags.slice(0, 5).forEach((flag, index) => {\n        extractedData[`Issue_${index + 1}_Type`] = flag.type;\n        extractedData[`Issue_${index + 1}_Field`] = flag.field || 'N/A';\n        extractedData[`Issue_${index + 1}_Message`] = flag.message;\n        if (flag.weighted_severity) {\n            extractedData[`Issue_${index + 1}_Severity`] = flag.weighted_severity;\n        }\n    });\n    \n    // === RECOMMENDATIONS ===\n    const recommendations = report.recommendations || data.full_validation_report?.recommendations || [];\n    extractedData['Total_Recommendations'] = recommendations.length;\n    \n    recommendations.slice(0, 3).forEach((rec, index) => {\n        extractedData[`Recommendation_${index + 1}`] = rec;\n    });\n    \n    // === EXTRA METADATA ===\n    if (validation.destination_country) {\n        extractedData['Destination_Country'] = validation.destination_country;\n    }\n    \n    return extractedData;\n}\n\n/**\n * Escapet speciale karakters in een string om het veilig te gebruiken in XML.\n */\nfunction escapeXml(unsafe) {\n    if (unsafe === null || unsafe === undefined) return '';\n    return String(unsafe)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n\n// === HOOFDLOGICA ===\n\n// 1. Extraheer ALLE data dynamisch\nconst reportData = extractAllData(jsonData);\n\n// 2. Genereer een veilige bestandsnaam\nconst workerName = reportData.Worker_Name || 'Unknown_Worker';\nconst cleanWorkerName = workerName.replace(/[^a-zA-Z0-9\\s-]/g, '').replace(/\\s+/g, '_');\nconst dateStr = new Date().toISOString().split('T')[0];\nconst fileName = `Complete_Validation_Report_${cleanWorkerName}_${dateStr}.xls`;\n\n// 3. Bouw de Excel XML-content op\nconst excelXML = `<?xml version=\"1.0\"?>\n<?mso-application progid=\"Excel.Sheet\"?>\n<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\n xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\">\n <DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\n  <Title>Complete Document Validation Report</Title>\n  <Subject>Worker: ${escapeXml(workerName)}</Subject>\n  <Created>${new Date().toISOString()}</Created>\n </DocumentProperties>\n <Styles>\n  <Style ss:ID=\"Header\">\n   <Font ss:Bold=\"1\" ss:Size=\"11\"/>\n   <Interior ss:Color=\"#D9E1F2\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Pass\">\n   <Interior ss:Color=\"#C6EFCE\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Fail\">\n   <Interior ss:Color=\"#FFC7CE\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Warn\">\n   <Interior ss:Color=\"#FFEB9C\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Critical\">\n   <Interior ss:Color=\"#FF6B6B\" ss:Pattern=\"Solid\"/>\n   <Font ss:Bold=\"1\"/>\n  </Style>\n  <Style ss:ID=\"Default\"/>\n </Styles>\n <Worksheet ss:Name=\"Complete Validation Report\">\n  <Table>\n    <Column ss:StyleID=\"Header\" ss:AutoFitWidth=\"1\" ss:Width=\"200\"/>\n    <Column ss:AutoFitWidth=\"1\" ss:Width=\"300\"/>\n${Object.entries(reportData).map(([key, value]) => {\n    const valStr = String(value).toUpperCase();\n    let valueStyleID = 'Default';\n    \n    // Meer geavanceerde logica voor celkleuren\n    if (valStr.includes('PASS') || valStr.includes('YES') || valStr.includes('MATCH') || valStr === 'TRUE' || valStr.includes('VALID')) {\n        valueStyleID = 'Pass';\n    } else if (valStr.includes('FAIL') || valStr.includes('NO') || valStr.includes('MISMATCH') || valStr === 'FALSE') {\n        valueStyleID = 'Fail';\n    } else if (valStr.includes('CRITICAL')) {\n        valueStyleID = 'Critical';\n    } else if (valStr.includes('WARNING') || valStr.includes('REVIEW') || valStr.includes('UNKNOWN') || valStr.includes('ERROR')) {\n        valueStyleID = 'Warn';\n    }\n    \n    return `    <Row>\n     <Cell ss:StyleID=\"Header\"><Data ss:Type=\"String\">${escapeXml(key.replace(/_/g, ' '))}</Data></Cell>\n     <Cell ss:StyleID=\"${valueStyleID}\"><Data ss:Type=\"String\">${escapeXml(String(value ?? ''))}</Data></Cell>\n    </Row>`;\n}).join('\\n')}\n  </Table>\n </Worksheet>\n</Workbook>`;\n\n// 4. Log de output voor debugging\nconsole.log(`Complete Excel-bestand gegenereerd voor: ${workerName}`);\nconsole.log(`Aantal datapunten geëxtraheerd: ${Object.keys(reportData).length}`);\nconsole.log(`Bestandsnaam: ${fileName}`);\n\n// 5. Return de data\nreturn {\n    json: {\n        ...jsonData,\n        excelGenerated: true,\n        excelFilename: fileName,\n        totalDataPoints: Object.keys(reportData).length,\n        reportSummary: {\n            decision: reportData.Decision,\n            status: reportData.Overall_Status,\n            criticalIssues: reportData.Critical_Issues_Count,\n            totalDocuments: reportData.Total_Documents_Processed\n        }\n    },\n    binary: {\n        ...($input.first().binary || {}), \n        file: {\n            data: Buffer.from(excelXML, 'utf8').toString('base64'),\n            mimeType: 'application/vnd.ms-excel', \n            fileName: fileName\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -688,
        864
      ],
      "id": "979f6764-7473-473c-8480-d9702788e2a0",
      "name": "create xlsx"
    },
    {
      "parameters": {
        "jsCode": "function convertIsoToEuropean(dateStr) {\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n        const [year, month, day] = dateStr.split(\"-\");\n        return `${day}/${month}/${year}`;\n    }\n    return dateStr;\n}\n\nfunction convertDatesInObject(obj) {\n    if (Array.isArray(obj)) {\n        return obj.map(convertDatesInObject);\n    } else if (typeof obj === 'object' && obj !== null) {\n        const newObj = {};\n        for (const key in obj) {\n            newObj[key] = convertDatesInObject(obj[key]);\n        }\n        return newObj;\n    } else if (typeof obj === 'string') {\n        return convertIsoToEuropean(obj);\n    } else {\n        return obj;\n    }\n}\n\nconst validationResults = [];\n\nitems.forEach(item => {\n    try {\n        const outputText = item.json.output;\n        const jsonMatch = outputText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n\n        let jsonData;\n        if (jsonMatch && jsonMatch[1]) {\n            jsonData = JSON.parse(jsonMatch[1].trim());\n        } else {\n            jsonData = JSON.parse(outputText.trim());\n        }\n\n        const convertedData = convertDatesInObject(jsonData);\n        validationResults.push(convertedData);\n\n    } catch (e) {\n        console.log('Error parsing AI output:', e.message);\n    }\n});\n\nif (validationResults.length === 0) {\n    return [{\n        json: {\n            decision: \"FAIL\",\n            reason: \"No valid validation results found from AI Agent.\",\n            action: \"reject\",\n            missing_documents: [\"Unable to determine\"],\n            recommendation: \"AI did not produce a valid validation report. Please investigate AI Agent output.\"\n        }\n    }];\n}\n\n// AANGEPAST: De validatieregels voor EU-werkdocumenten zijn bijgewerkt.\nfunction combineValidationResults(results) {\n    const combinedFlags = [];\n    const combinedRecommendations = [];\n    const missingDocuments = [];\n    let overallStatus = \"PASS\";\n    let totalCriticalIssues = 0;\n    \n    // ✅ HERSCHREVEN: De regels voor 'id_card' en 'passport' zijn gecorrigeerd.\n    // De controle op een stempel (requiresStamp) is nu 'false'.\n    const documentTypeRules = {\n        'a1_form': { required: true, priority: 'CRITICAL', criticalWeight: 5, requiresStamp: true, requiresSignature: true },\n        'id_card': { required: true, priority: 'CRITICAL', criticalWeight: 5, requiresStamp: false, requiresSignature: false },\n        'limosa': { required: true, priority: 'CRITICAL', criticalWeight: 4, requiresStamp: false, requiresSignature: false },\n        'svwoh': { required: true, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'certificate': { required: true, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'passport': { required: false, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'residence_permit': { required: false, priority: 'HIGH', criticalWeight: 3, requiresStamp: true, requiresSignature: false }\n    };\n    \n    // Track alle document types uit alle reports\n    const allDocumentTypes = new Set();\n    const documentsByType = {};\n    const stampSignatureCompliance = {\n        missing_stamps: [],\n        missing_signatures: [],\n        low_confidence_items: [],\n        luik_checkbox_issues: []\n    };\n    \n    console.log(`Processing ${results.length} EU work document validation reports`);\n\n    results.forEach((report, index) => {\n        // Gebruik de overall_status direct van het AI rapport\n        const reportStatus = report.validation_summary?.overall_status;\n        if (reportStatus === \"FAIL\") {\n            overallStatus = \"FAIL\";\n        } else if (reportStatus === \"WARNING\" && overallStatus !== \"FAIL\") {\n            overallStatus = \"WARNING\";\n        }\n\n        // Extract ALL document types uit single report\n        const reportDocumentTypes = extractAllDocumentTypes(report);\n        reportDocumentTypes.forEach(docType => {\n            allDocumentTypes.add(docType);\n            if (!documentsByType[docType]) {\n                documentsByType[docType] = [];\n            }\n            documentsByType[docType].push({ report, index, docType });\n        });\n        \n        // Analyseer compliance per specifiek document type\n        analyzeReportCompliance(report, reportDocumentTypes, stampSignatureCompliance, documentTypeRules);\n        \n        // Verzamel flags met correcte weging\n        if (report.flags_and_warnings) {\n            report.flags_and_warnings.forEach(flag => {\n                // Gebruik gemiddelde weging voor mixed document reports\n                const avgWeight = reportDocumentTypes.reduce((sum, type) => \n                    sum + (documentTypeRules[type]?.criticalWeight || 1), 0) / reportDocumentTypes.length;\n                \n                const weightedFlag = {\n                    ...flag,\n                    document_index: index,\n                    document_type: reportDocumentTypes.join(','),\n                    weighted_severity: calculateWeightedSeverity(flag.type, avgWeight)\n                };\n                combinedFlags.push(weightedFlag);\n            });\n        }\n\n        // EU-specifieke aanbevelingen\n        if (report.recommendations) {\n            const docRecommendations = Array.isArray(report.recommendations) \n                ? report.recommendations \n                : [report.recommendations];\n            docRecommendations.forEach(rec => {\n                combinedRecommendations.push(`[${reportDocumentTypes.join(',').toUpperCase()}] ${rec}`);\n            });\n        }\n\n        // Check kritieke issues\n        const avgWeight = reportDocumentTypes.reduce((sum, type) => \n            sum + (documentTypeRules[type]?.criticalWeight || 1), 0) / reportDocumentTypes.length;\n        const criticalIssues = (report.flags_and_warnings || []).filter(flag =>\n            [\"CRITICAL\", \"ERROR\"].includes(flag.type)\n        ).length;\n        \n        totalCriticalIssues += criticalIssues * avgWeight;\n\n        // Check missing documents\n        if (report.mandatory_documents_check?.all_mandatory_present === \"NO\") {\n            const missing = report.mandatory_documents_check.missing_documents || [];\n            missingDocuments.push(...missing);\n        }\n    });\n    \n    // Extract alle document types uit een report\n    function extractAllDocumentTypes(report) {\n        const types = [];\n        if (report.original_document_details) {\n            const details = report.original_document_details;\n            if (details.social_security_data?.document_type) {\n                types.push(details.social_security_data.document_type);\n            }\n            if (details.identity_document_data?.document_type) {\n                types.push(details.identity_document_data.document_type);\n            }\n            if (details.work_notification_data?.document_type) {\n                types.push(details.work_notification_data.document_type);\n            }\n            if (details.safety_certificate_data?.document_type) {\n                types.push(details.safety_certificate_data.document_type);\n            }\n            if (details.safety_certificate_data_2?.document_type) {\n                types.push(details.safety_certificate_data_2.document_type);\n            }\n        }\n        return types.length > 0 ? types : ['certificate']; // fallback\n    }\n    \n    // Analyseer compliance per report met correcte data reading\n    function analyzeReportCompliance(report, documentTypes, compliance, rules) {\n        if (!report.original_document_details) return;\n        \n        const details = report.original_document_details;\n        \n        // Check social security data (A1)\n        if (details.social_security_data?.additional_fields) {\n            const fields = details.social_security_data.additional_fields;\n            const docType = details.social_security_data.document_type || 'a1_form';\n            const typeRules = rules[docType];\n            \n            if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n            }\n            if (typeRules?.requiresSignature && fields.signature_present === false) {\n                compliance.missing_signatures.push(`${docType}: Required signature missing`);\n            }\n            if (fields.signature_confidence && fields.signature_confidence < 0.5) {\n                compliance.low_confidence_items.push(`${docType}: Low signature confidence (${fields.signature_confidence})`);\n            }\n            if (fields.stamp_confidence && fields.stamp_confidence < 0.5) {\n                compliance.low_confidence_items.push(`${docType}: Low stamp confidence (${fields.stamp_confidence})`);\n            }\n            \n            // Check Luik checkboxes voor A1\n            if (docType === 'a1_form') {\n                if (fields.luik_3_2_checked === false && fields.luik_4_1_1_checked === false) {\n                    compliance.luik_checkbox_issues.push('A1: Neither Luik 3.2 nor 4.1.1 is checked - worker status unclear');\n                }\n            }\n        }\n        \n        // Check identity document\n        if (details.identity_document_data?.additional_fields) {\n            const fields = details.identity_document_data.additional_fields;\n            const docType = details.identity_document_data.document_type || 'id_card';\n            const typeRules = rules[docType];\n            \n            if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n            }\n            if (typeRules?.requiresSignature && fields.signature_present === false) {\n                compliance.missing_signatures.push(`${docType}: Required signature missing`);\n            }\n        }\n        \n        // Check work notification (limosa)\n        if (details.work_notification_data?.additional_fields) {\n            const fields = details.work_notification_data.additional_fields;\n            const docType = details.work_notification_data.document_type || 'limosa';\n            const typeRules = rules[docType];\n            \n            // Limosa typically doesn't require stamps/signatures, so only check if rules say it does\n            if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n            }\n            if (typeRules?.requiresSignature && fields.signature_present === false) {\n                compliance.missing_signatures.push(`${docType}: Required signature missing`);\n            }\n        }\n        \n        // Check safety certificates\n        [details.safety_certificate_data, details.safety_certificate_data_2].forEach((certData, index) => {\n            if (certData?.additional_fields) {\n                const fields = certData.additional_fields;\n                const docType = certData.document_type || 'certificate';\n                const typeRules = rules[docType];\n                \n                if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                    compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n                }\n                if (typeRules?.requiresSignature && fields.signature_present === false) {\n                    compliance.missing_signatures.push(`${docType}: Required signature missing`);\n                }\n            }\n        });\n    }\n    \n    function calculateWeightedSeverity(flagType, weight) {\n        const baseValues = { 'CRITICAL': 10, 'ERROR': 7, 'WARNING': 4, 'INFO': 1 };\n        return (baseValues[flagType] || 1) * weight;\n    }\n    \n    // Creëer correcte type summary gebaseerd op alle gevonden types\n    const typeSummary = Array.from(allDocumentTypes).map(type => ({\n        type,\n        count: documentsByType[type]?.length || 0,\n        required: documentTypeRules[type]?.required || false,\n        status: documentsByType[type] ? getTypeStatus(documentsByType[type]) : 'NOT_FOUND'\n    }));\n\n    function getTypeStatus(documentsOfType) {\n        const statuses = documentsOfType.map(doc => doc.report.validation_summary?.overall_status);\n        if (statuses.includes('FAIL')) return 'FAIL';\n        if (statuses.includes('WARNING')) return 'WARNING';\n        return 'PASS';\n    }\n\n    // Bereken totaal documenten correct\n    const totalDocuments = results.reduce((total, report) => {\n        return total + (report.validation_summary?.documents_validated?.length || 0);\n    }, 0);\n\n    // Voeg alleen echte compliance issues toe als flags\n    stampSignatureCompliance.missing_stamps.forEach(issue => {\n        combinedFlags.push({\n            type: 'CRITICAL',\n            field: 'stamp_compliance',\n            message: issue,\n            document_type: 'compliance_check',\n            weighted_severity: 50\n        });\n    });\n    \n    stampSignatureCompliance.missing_signatures.forEach(issue => {\n        combinedFlags.push({\n            type: 'CRITICAL',\n            field: 'signature_compliance', \n            message: issue,\n            document_type: 'compliance_check',\n            weighted_severity: 45\n        });\n    });\n    \n    stampSignatureCompliance.luik_checkbox_issues.forEach(issue => {\n        combinedFlags.push({\n            type: 'ERROR',\n            field: 'luik_compliance',\n            message: issue,\n            document_type: 'a1_form',\n            weighted_severity: 35\n        });\n    });\n\n    return {\n        validation_summary: {\n            overall_status: overallStatus,\n            total_documents: totalDocuments,\n            documents_processed: totalDocuments,\n            document_types_summary: typeSummary\n        },\n        flags_and_warnings: combinedFlags.sort((a, b) => b.weighted_severity - a.weighted_severity),\n        recommendations: combinedRecommendations,\n        mandatory_documents_check: {\n            all_mandatory_present: missingDocuments.length === 0 ? \"YES\" : \"NO\",\n            missing_documents: missingDocuments\n        },\n        eu_compliance_check: stampSignatureCompliance,\n        critical_issues_count: totalCriticalIssues,\n        individual_reports: results,\n        document_type_breakdown: documentsByType\n    };\n}\n\n// Gebruik gecombineerde resultaten\nconst aiReport = combineValidationResults(validationResults);\n\nlet decision = \"FAIL\";\nlet action = \"reject\";\nlet recommendation = \"No recommendation.\";\n\n// Gebruik AI rapport status als basis, override alleen bij echte problemen\nconst overallStatus = aiReport?.validation_summary?.overall_status;\nconst complianceIssues = aiReport.eu_compliance_check || {};\n\n// Start met AI beslissing\nswitch (overallStatus) {\n    case \"PASS\":\n        decision = \"PASS\";\n        action = \"approve\";\n        break;\n    case \"WARNING\":\n        decision = \"REVIEW\";\n        action = \"manual_review\";\n        break;\n    case \"FAIL\":\n        decision = \"FAIL\";\n        action = \"reject\";\n        break;\n    default:\n        decision = \"FAIL\";\n        action = \"reject\";\n}\n\n// Override alleen bij echte compliance problemen\nconst realStampIssues = complianceIssues.missing_stamps?.length || 0;\nconst realSignatureIssues = complianceIssues.missing_signatures?.length || 0;\nconst realLuikIssues = complianceIssues.luik_checkbox_issues?.length || 0;\n\nif (realStampIssues > 0 || realSignatureIssues > 0) {\n    decision = \"FAIL\";\n    action = \"reject\";\n    recommendation = \"Required stamps or signatures missing from critical EU work documents. Please ensure all documents are properly stamped and signed.\";\n} else if (realLuikIssues > 0) {\n    decision = \"REVIEW\";\n    action = \"manual_review\";\n    recommendation = \"A1 form checkbox issues detected. Manual review required to verify worker employment status.\";\n} else {\n    // Gebruik AI aanbevelingen als er geen compliance issues zijn\n    recommendation = aiReport.recommendations?.join('; ') || \n                     (overallStatus === \"PASS\" ? \"All EU work documents validated successfully.\" : \n                      \"See validation report for details.\");\n}\n\nconst output = {\n    decision,\n    action,\n    overall_status: overallStatus,\n    total_documents_processed: aiReport.validation_summary.total_documents,\n    document_types_found: aiReport.validation_summary.document_types_summary,\n    critical_issues_count: aiReport.critical_issues_count || 0,\n    eu_compliance_summary: complianceIssues,\n    recommendation,\n    missing_documents: aiReport?.mandatory_documents_check?.missing_documents || [],\n    full_validation_report: aiReport\n};\n\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        400
      ],
      "id": "91a7fec5-a249-401c-8c4f-3449ee8b6306",
      "name": "json set"
    },
    {
      "parameters": {
        "jsCode": "// Met lokale datum formatting:\nconst today = new Date();\nconst validationDate = today.getFullYear() + '-' + \n                      String(today.getMonth() + 1).padStart(2, '0') + '-' + \n                      String(today.getDate()).padStart(2, '0');\n\nreturn items.map(item => {\n  // Combineer ALLE documenten tot 1 string\n  let allDocuments = '';\n  \n  if (item.json.data && Array.isArray(item.json.data)) {\n    item.json.data.forEach((doc, index) => {\n      if (doc.candidates && doc.candidates[0] && doc.candidates[0].content && doc.candidates[0].content.parts && doc.candidates[0].content.parts[0]) {\n        allDocuments += `\\n\\n=== DOCUMENT ${index + 1} ===\\n`;\n        allDocuments += doc.candidates[0].content.parts[0].text;\n        allDocuments += `\\n=== END DOCUMENT ${index + 1} ===\\n`;\n      }\n    });\n  }\n  \n  return {\n    ...item.json,\n    validation_date: validationDate,\n    combined_documents: allDocuments\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -448,
        400
      ],
      "id": "fc11341c-1d4a-4e0f-9b6c-ab7d97bd9c5a",
      "name": "Code"
    },
    {
      "parameters": {
        "formTitle": "Deployment Compliance Checker",
        "formDescription": "=Primary function of checking and verifying the compliance of workers' documents and schedules for deployment on Belgian construction sites.\n\n**Please note:** This system is optimized for PDF documents only. While image files (JPG, PNG, etc.) can be uploaded, they may not always process correctly and could result in errors or incomplete verification. For best results, please convert all documents to PDF format before uploading.\nThe following documents are required:\nID card or passport\nA1 document\nLimosa\nVCA or SCC certificate\n\nIf any of these documents are missing, the result will automatically be marked as a fail.",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Mail",
              "fieldType": "email",
              "placeholder": "Your mail adress here!",
              "requiredField": true
            },
            {
              "fieldLabel": "PDF",
              "fieldType": "file",
              "acceptFileTypes": "PDF",
              "requiredField": true
            }
          ]
        },
        "options": {
          "appendAttribution": false,
          "respondWithOptions": {
            "values": {
              "formSubmittedText": "Response Recorded Thank you for your submission. Your response has been successfully recorded.  Email Notification: You will receive a detailed email response within the next few minutes.  Next Steps: Please check your inbox and spam folder for our response.  Support: If you don't receive an email within 10 minutes, please contact your system administrator.  You may now close this window."
            }
          },
          "customCss": ":root {\n\t--font-family: 'Open Sans', sans-serif;\n\t--font-weight-normal: 400;\n\t--font-weight-bold: 600;\n\t--font-size-body: 12px;\n\t--font-size-label: 16px; /* vergroot van 14px */\n\t--font-size-test-notice: 12px;\n\t--font-size-input: 16px; /* vergroot van 14px */\n\t--font-size-header: 20px;\n\t--font-size-paragraph: 14px;\n\t--font-size-link: 12px;\n\t--font-size-error: 12px;\n\t--font-size-html-h1: 28px;\n\t--font-size-html-h2: 20px;\n\t--font-size-html-h3: 16px;\n\t--font-size-html-h4: 14px;\n\t--font-size-html-h5: 12px;\n\t--font-size-html-h6: 10px;\n\t--font-size-subheader: 14px;\n\t/* Colors - Altrad Theme */\n\t--color-background: #f8f9fa;\n\t--color-test-notice-text: #E31E24;\n\t--color-test-notice-bg: #fef7f7;\n\t--color-test-notice-border: #f5c6c7;\n\t--color-card-bg: #ffffff;\n\t--color-card-border: #e1e5e9;\n\t--color-card-shadow: rgba(227, 30, 36, 0.08);\n\t--color-link: #6b6b6b;\n\t--color-header: #2c2c2c;\n\t--color-label: #2c2c2c;\n\t--color-input-border: #e1e5e9;\n\t--color-input-text: #6b6b6b;\n\t--color-focus-border: #E31E24;\n\t--color-submit-btn-bg: #E31E24;\n\t--color-submit-btn-text: #ffffff;\n\t--color-error: #E31E24;\n\t--color-required: #E31E24;\n\t--color-clear-button-bg: #6b6b6b;\n\t--color-html-text: #2c2c2c;\n\t--color-html-link: #E31E24;\n\t--color-header-subtext: #6b6b6b;\n\t/* Border Radii */\n\t--border-radius-card: 8px;\n\t--border-radius-input: 6px;\n\t--border-radius-clear-btn: 50%;\n\t--card-border-radius: 8px;\n\t/* Spacing */\n\t--padding-container-top: 24px;\n\t--padding-card: 24px;\n\t--padding-test-notice-vertical: 12px;\n\t--padding-test-notice-horizontal: 24px;\n\t--margin-bottom-card: 16px;\n\t--padding-form-input: 18px; /* vergroot van 12px */\n\t--card-padding: 24px;\n\t--card-margin-bottom: 16px;\n\t/* Dimensions */\n\t--container-width: 520px; /* vergroot van 448px */\n\t--submit-btn-height: 56px; /* vergroot van 48px */\n\t--checkbox-size: 18px;\n\t/* Others */\n\t--box-shadow-card: 0px 4px 16px 0px var(--color-card-shadow);\n\t--opacity-placeholder: 0.5;\n\t/* Logo */\n\t--logo-url: url('https://bnl.altradservices.com/assets/images/b/Benelux_RVB-660c4912.jpg');\n}"
        }
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        -2304,
        464
      ],
      "id": "009c2647-82dc-452a-b28f-7dfa4ae138fd",
      "name": "On form submission",
      "webhookId": "9e3bfff9-b57f-408f-8414-8064628edd98"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        -736,
        400
      ],
      "id": "3a016a1b-86a2-4ebe-8afd-a4d895675306",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [\n    {\n      \"parts\": [\n        {\n          \"text\": \"You will receive one or more official documents belonging to a single individual. These documents may include, but are not limited to:\\n\\n- Passports and ID cards (EU and non-EU)\\n- Residence permits, work permits, A1 forms\\n- Limosa declarations\\n- VCA, SVWOH, SCC or similar safety certificates\\n- Diplomas, training certificates, and professional qualifications\\n- Any document related to employment eligibility, education or legal stay in Belgium or the EU\\n\\nSome individuals are nationals of third countries (outside the EU/EEA/Switzerland) and will submit more than the typical number of documents. Handle all documents equally and return structured output per document.\\n\\nIf a document is spread over multiple pages (such as an A1 form), detect that the pages belong together based on layout, headers, document number, or visual consistency. In that case, return a single merged JSON object with all combined data and a concatenated raw_text field. Do not split multi-page documents into multiple objects.\\n\\nVisually inspect the entire document image for official stamps (ink or embossed) and handwritten signatures. These elements are crucial for document validity. Populate the `stamp_present` and `signature_present` fields accurately based on this visual check.\\n\\nAdditionally, carefully examine all documents for checked boxes or marked text fields, particularly in A1 forms where specific sections may be checked or marked to indicate selections, declarations, or confirmations. Pay special attention to whether Luik 3.2 and Luik 4.1.1 are checked/marked, as these are critical administrative indicators. Document these checked/marked areas as they contain important administrative information.\\n\\n**Information regarding signatures or stamps must be returned/included with validation_date and can be found in the accompanying data provided.**\\n\\nAt the top level of the response, return two additional fields:\\n\\n1. `person_check`: an object containing:\\n   - `same_person` (boolean): whether all documents likely belong to the same individual (≥70% name match).\\n   - `cross_document_name_match_score` (float): the average name similarity score between all documents (0.0–1.0).\\n   - `name_variants` (array): all unique detected full name variants across documents.\\n\\n2. `documents_check`: an object containing:\\n   - `required_documents` (array): based on nationality (EU/EEA/CH or third-country), list required document types.\\n   - `present_documents` (array): list of all detected document types.\\n   - `missing_required_documents` (array): required types that were not found.\\n   - `all_required_documents_present` (boolean): true if nothing is missing.\\n\\nThen return `documents` as a strict JSON array, where each document (or merged multi-page document) is one object.\\n\\nEach document must include the following structure:\\n\\n- document_type\\n- country_of_origin\\n- full_name\\n- date_of_birth (format: YYYY-MM-DD)\\n- document_number\\n- expiry_date\\n- certificate_id\\n- diploma_title\\n- employer_name\\n- employment_period (e.g. from-to dates)\\n- exam_date\\n- valid_until\\n- stamp_present: true or false\\n- stamp_confidence: float (0.0–1.0)\\n- signature_present: true or false\\n- signature_confidence: float (0.0–1.0)\\n- raw_text: the full OCR output, even if noisy or partial\\n\\nExample output:\\n\\n{\\n  \\\"person_check\\\": {\\n    \\\"same_person\\\": true,\\n    \\\"cross_document_name_match_score\\\": 0.81,\\n    \\\"name_variants\\\": [\\\"Nihad Aliyev\\\", \\\"ALIYEV Nihad\\\", \\\"N.A. Aliyev\\\"]\\n  },\\n  \\\"documents_check\\\": {\\n    \\\"required_documents\\\": [\\\"id_card\\\", \\\"a1_form\\\", \\\"limosa\\\"],\\n    \\\"present_documents\\\": [\\\"id_card\\\", \\\"a1_form\\\", \\\"limosa\\\", \\\"svwoh\\\"],\\n    \\\"missing_required_documents\\\": [],\\n    \\\"all_required_documents_present\\\": true\\n  },\\n  \\\"documents\\\": [\\n    {\\n      \\\"document_type\\\": \\\"id_card\\\",\\n      \\\"country_of_origin\\\": \\\"LTU\\\",\\n      \\\"full_name\\\": \\\"ALIYEV Nihad\\\",\\n      \\\"date_of_birth\\\": \\\"1995-01-31\\\",\\n      \\\"document_number\\\": \\\"760304769\\\",\\n      \\\"expiry_date\\\": \\\"2025-11-06\\\",\\n      \\\"certificate_id\\\": null,\\n      \\\"diploma_title\\\": null,\\n      \\\"employer_name\\\": null,\\n      \\\"employment_period\\\": null,\\n      \\\"exam_date\\\": null,\\n      \\\"valid_until\\\": null,\\n      \\\"stamp_present\\\": false,\\n      \\\"stamp_confidence\\\": 0.0,\\n      \\\"signature_present\\\": true,\\n      \\\"signature_confidence\\\": 0.75,\\n      \\\"raw_text\\\": \\\"...\\\"\\n    }\\n    // More documents here...\\n  ]\\n}\\n\\nOnly return valid JSON. Do not include explanations, markdown, bullet points, or formatting. Return pure machine-readable JSON output only. Combine the documents that are the same, i.e. A1, together.\\n\\nThe `date_of_birth` is a critical field for ID cards and passports. If this field is not explicitly labeled or readable, actively search for a national identification number (e.g., Romanian CNP/CRP, Polish PESEL, etc.). These numbers often embed the date of birth near the beginning in a `YYMMDD` format.\\n* **Logic:** You must derive the date of birth from this number. The century (`19xx` vs `20xx`) is often indicated by a preceding digit.\\n* **Example:** A Romanian CRP number starting with `1810421` indicates a male (`1`) born on April 21, 1981 (`810421`). This must be normalized to `1981-04-21`. A number starting with `5` or `6` often indicates a birth year in the 2000s (e.g., `501...` for `2001`).\\n* **Task:** Always extract, interpret, and normalize this date into the `YYYY-MM-DD` format and populate the `date_of_birth` field. Do not leave this field null if the information can be derived. Check all documents extra for signatures and stamps!\"\n        },\n        {\n          \"inline_data\": {\n            \"mime_type\": \"application/pdf\",\n            \"data\": \"{{ $json.data }}\"\n          }\n        }\n      ]\n    }\n  ]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1008,
        400
      ],
      "id": "c48bac37-ff61-4cbb-b505-8d73123b21ad",
      "name": "Extract PDF Content Using Gemini Vision",
      "credentials": {
        "httpQueryAuth": {
          "id": "t6Npfn3CB5NrgzCP",
          "name": "Query Auth account"
        }
      }
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "destinationKey": "=data",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -1232,
        400
      ],
      "id": "8cb2d567-c955-4c97-919c-50c472748a77",
      "name": "Transform to base64"
    },
    {
      "parameters": {
        "jsCode": "// DYNAMIC AND ROBUST VERSION - Processes variable number of documents\nconst inputData = $input.first().json;\n\n// --- Helper Functions ---\nfunction getValue(obj, path, defaultValue = 'N/A') {\n    try {\n        const value = path.split('.').reduce((acc, key) => acc && acc[key], obj);\n        return value !== undefined && value !== null ? value : defaultValue;\n    } catch {\n        return defaultValue;\n    }\n}\n\nfunction formatArray(arr) {\n    if (Array.isArray(arr)) {\n        return arr.join(', ');\n    }\n    return arr || 'N/A';\n}\n\nfunction calculateAge(birthDate) {\n    if (!birthDate || birthDate === 'N/A') return 'N/A';\n    try {\n        // Tries DD/MM/YYYY and YYYY-MM-DD\n        let date;\n        if (birthDate.includes('/')) {\n            const parts = birthDate.split('/');\n            date = new Date(parts[2], parts[1] - 1, parts[0]);\n        } else if (birthDate.includes('-')) {\n            date = new Date(birthDate);\n        } else {\n            return 'N/A';\n        }\n        \n        const today = new Date();\n        let age = today.getFullYear() - date.getFullYear();\n        const m = today.getMonth() - date.getMonth();\n        if (m < 0 || (m === 0 && today.getDate() < date.getDate())) {\n            age--;\n        }\n        return isNaN(age) ? 'N/A' : age;\n    } catch {\n        return 'N/A';\n    }\n}\n\n// Function to generate HTML card for ANY document type - fully dynamic\nfunction renderDocumentCard(category, doc, index = 0) {\n    const data = doc || {};\n    \n    // Create human-readable title from category name\n    let baseTitle = category.replace(/_data$/, '').replace(/_/g, ' ')\n                           .replace(/\\b\\w/g, l => l.toUpperCase());\n    \n    // Add index if there are multiple documents of the same type\n    const title = index > 0 ? `${baseTitle} ${index + 1}` : baseTitle;\n    \n    // Special title mappings for common document types\n    const titleMappings = {\n        'Social Security': 'A1 Social Security Certificate',\n        'Identity Document': 'Identity Document',\n        'Work Notification': 'Work Notification',\n        'Safety Certificate': 'Safety Certificate',\n        'Professional Certificate': 'Professional Certificate',\n        'Training Certificate': 'Training Certificate'\n    };\n    \n    let finalTitle = titleMappings[baseTitle] || baseTitle;\n    \n    // Special handling for identity documents - show ID Card or Passport\n    if (category === 'identity_document_data' && data.document_type) {\n        const docType = data.document_type.toLowerCase();\n        if (docType.includes('passport')) {\n            finalTitle = index > 0 ? `Passport ${index + 1}` : 'Passport';\n        } else if (docType.includes('id') || docType.includes('identity')) {\n            finalTitle = index > 0 ? `ID Card ${index + 1}` : 'ID Card';\n        } else {\n            // Use the actual document type if available\n            finalTitle = index > 0 ? `${data.document_type} ${index + 1}` : data.document_type;\n        }\n    }\n    \n    // Generate details dynamically from all available fields\n    let details = '';\n    \n    // Define field display mappings and priorities\n    const fieldMappings = {\n        // Common fields\n        'document_type': 'Document Type',\n        'document_number': 'Document Number',\n        'certificate_number': 'Certificate Number',\n        'expiry_date': 'Expiry Date',\n        'issue_date': 'Issue Date',\n        'issuing_country': 'Issuing Country',\n        'issuing_authority': 'Issuing Authority',\n        \n        // Personal info\n        'worker_name': 'Worker Name',\n        'holder_name': 'Holder Name',\n        'employee_name': 'Employee Name',\n        'given_names': 'Given Names',\n        'surname': 'Surname',\n        'birth_date': 'Date of Birth',\n        'nationality': 'Nationality',\n        'gender': 'Gender',\n        'personal_identifier': 'Personal ID',\n        \n        // Work-related\n        'work_period_start': 'Work Period Start',\n        'work_period_end': 'Work Period End',\n        'sending_company': 'Sending Company',\n        'employer_name': 'Employer',\n        'work_location': 'Work Location',\n        'sector': 'Sector',\n        'profession': 'Profession',\n        'notification_country': 'Notification Country',\n        \n        // Certificate specific\n        'certificate_type': 'Certificate Type',\n        'issue_place': 'Issue Place',\n        'exam_language': 'Exam Language',\n        'validity_period': 'Validity Period',\n        'training_provider': 'Training Provider',\n        \n        // Additional\n        'director_manager': 'Director/Manager',\n        'receiving_companies': 'Receiving Companies'\n    };\n    \n    // Priority order for displaying fields\n    const fieldPriority = [\n        'document_type', 'certificate_type', 'document_number', 'certificate_number',\n        'worker_name', 'holder_name', 'employee_name', 'given_names', 'surname',\n        'work_period_start', 'work_period_end', 'expiry_date', 'issue_date',\n        'employer_name', 'sending_company', 'work_location', 'sector',\n        'issuing_country', 'issuing_authority', 'nationality', 'birth_date',\n        'personal_identifier', 'gender', 'profession', 'notification_country',\n        'issue_place', 'exam_language', 'director_manager', 'receiving_companies'\n    ];\n    \n    // Process fields in priority order first\n    for (const field of fieldPriority) {\n        if (data[field] !== undefined && data[field] !== null && data[field] !== '') {\n            const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            let value = data[field];\n            \n            // Format arrays nicely\n            if (Array.isArray(value)) {\n                value = formatArray(value);\n            }\n            \n            details += `<p><strong>${displayName}:</strong> ${value}</p>\\n                `;\n        }\n    }\n    \n    // Add any remaining fields not in priority list\n    for (const [field, value] of Object.entries(data)) {\n        if (!fieldPriority.includes(field) && \n            field !== 'additional_fields' && \n            value !== undefined && value !== null && value !== '') {\n            \n            const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            let displayValue = value;\n            \n            if (Array.isArray(displayValue)) {\n                displayValue = formatArray(displayValue);\n            } else if (typeof displayValue === 'object') {\n                // Skip complex objects for now\n                continue;\n            }\n            \n            details += `<p><strong>${displayName}:</strong> ${displayValue}</p>\\n                `;\n        }\n    }\n    \n    // Add additional_fields if they exist\n    if (data.additional_fields && typeof data.additional_fields === 'object') {\n        for (const [field, value] of Object.entries(data.additional_fields)) {\n            if (value !== undefined && value !== null && value !== '') {\n                const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                details += `<p><strong>${displayName}:</strong> ${value}</p>\\n                `;\n            }\n        }\n    }\n    \n    // If no details were generated, show a generic message\n    if (!details.trim()) {\n        details = '<p>No detailed information available for this document.</p>';\n    }\n    \n    return `<div class=\"info-card\"><h4>${finalTitle}</h4>${details}</div>`;\n}\n\n// --- Data Extraction ---\nconst decision = getValue(inputData, 'decision', 'UNKNOWN');\nconst overallStatus = getValue(inputData, 'overall_status', 'UNKNOWN');\nconst validationData = getValue(inputData, 'full_validation_report', {});\nconst firstReport = getValue(validationData, 'individual_reports.0', {});\n\n// Get all original document details\nconst originalDocs = getValue(firstReport, 'original_document_details', {});\n\n// Extract data objects/arrays for easy access - FULLY DYNAMIC\nconst personalData = getValue(firstReport, 'personal_data_comparison', {});\n\n// Create a flat array of ALL documents for easier searching\nconst allDocuments = [];\nfor (const [category, docData] of Object.entries(originalDocs)) {\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        documents.forEach(doc => {\n            if (doc) {\n                allDocuments.push({ category, ...doc });\n            }\n        });\n    }\n}\n\n// Dynamic employee information extraction - searches through ALL documents\nfunction findFieldInDocuments(fieldNames, fallback = 'N/A') {\n    // First try personal data comparison\n    for (const fieldName of fieldNames) {\n        const personalValue = getValue(personalData, `${fieldName}.social_security_doc`) ||\n                             getValue(personalData, `${fieldName}.identity_doc`) ||\n                             getValue(personalData, `${fieldName}.work_notification`);\n        if (personalValue && personalValue !== 'N/A') return personalValue;\n    }\n    \n    // Then search through all documents\n    for (const fieldName of fieldNames) {\n        for (const doc of allDocuments) {\n            if (doc[fieldName] && doc[fieldName] !== 'N/A') {\n                return doc[fieldName];\n            }\n        }\n    }\n    \n    // Special handling for combined names\n    if (fieldNames.includes('worker_name')) {\n        for (const doc of allDocuments) {\n            if (doc.given_names && doc.surname) {\n                return `${doc.given_names} ${doc.surname}`.trim();\n            }\n        }\n    }\n    \n    return fallback;\n}\n\nconst workerName = findFieldInDocuments(['worker_name', 'holder_name', 'employee_name', 'given_names']);\nconst birthDate = findFieldInDocuments(['birth_date']);\nconst personalId = findFieldInDocuments(['personal_identifier', 'employee_identification']);\nconst nationality = findFieldInDocuments(['nationality']);\nconst profession = findFieldInDocuments(['profession', 'sector']);\nconst age = calculateAge(birthDate);\n\n// Document status - DYNAMIC based on what's actually present\nconst mandatoryDocs = getValue(firstReport, 'mandatory_documents_check', {});\n\n// Create dynamic document status overview\nlet documentStatusHtml = '';\nconst documentCounts = {};\n\n// Count all document types\nfor (const category in originalDocs) {\n    const docData = originalDocs[category];\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        const validDocs = documents.filter(doc => doc && Object.keys(doc).length > 0);\n        if (validDocs.length > 0) {\n            documentCounts[category] = validDocs.length;\n        }\n    }\n}\n\n// Generate status for each document type found\nfor (const [category, count] of Object.entries(documentCounts)) {\n    const displayName = category.replace(/_data$/, '').replace(/_/g, ' ')\n                               .replace(/\\b\\w/g, l => l.toUpperCase());\n    const status = count > 0 ? '✓ Present' : '✗ Missing';\n    const countText = count > 1 ? ` (${count} documents)` : '';\n    documentStatusHtml += `<p><strong>${displayName}:</strong> ${status}${countText}</p>\\n            `;\n}\n\n// Also check mandatory document status if available\nconst mandatoryStatusMapping = {\n    'social_security_document_present': 'Social Security Document',\n    'identity_document_present': 'Identity Document', \n    'work_notification_present': 'Work Notification',\n    'safety_certificate_present': 'Safety Certificate',\n    'professional_certificate_present': 'Professional Certificate'\n};\n\nfor (const [key, displayName] of Object.entries(mandatoryStatusMapping)) {\n    if (mandatoryDocs[key] !== undefined) {\n        // Only show if not already covered by document counts\n        const category = displayName.toLowerCase().replace(/\\s+/g, '_') + '_data';\n        if (!documentCounts[category]) {\n            const status = mandatoryDocs[key] === 'YES' ? '✓ Present' : '✗ Missing';\n            documentStatusHtml += `<p><strong>${displayName}:</strong> ${status}</p>\\n            `;\n        }\n    }\n}\n\n// --- Dynamic HTML Generation ---\n\n// Generate HTML for all document cards - FULLY DYNAMIC with identity documents first\nlet documentDetailsHtml = '';\n\n// First, render identity documents (ID cards/passports) at the top\nif (originalDocs['identity_document_data']) {\n    const identityData = originalDocs['identity_document_data'];\n    const identityDocuments = Array.isArray(identityData) ? identityData : [identityData];\n    \n    identityDocuments.forEach((doc, index) => {\n        if (doc && Object.keys(doc).length > 0) {\n            documentDetailsHtml += renderDocumentCard('identity_document_data', doc, index);\n        }\n    });\n}\n\n// Then render all other document types\nfor (const category in originalDocs) {\n    // Skip identity documents as they're already rendered\n    if (category === 'identity_document_data') continue;\n    \n    const docData = originalDocs[category];\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        \n        documents.forEach((doc, index) => {\n            if (doc && Object.keys(doc).length > 0) {\n                documentDetailsHtml += renderDocumentCard(category, doc, index);\n            }\n        });\n    }\n}\n\n// Consistency checks\nconst consistency = {\n    name: getValue(personalData, 'name.status', 'UNKNOWN'),\n    birthDate: getValue(personalData, 'birth_date.status', 'UNKNOWN'),\n    personalId: getValue(personalData, 'personal_identifier.status', 'UNKNOWN'),\n    nationality: getValue(personalData, 'nationality.status', 'UNKNOWN')\n};\nconst crossConsistency = getValue(firstReport, 'cross_document_consistency', {});\n\n// Flags, warnings and recommendations\nconst flags = getValue(validationData, 'flags_and_warnings', []);\nconst recommendations = getValue(validationData, 'recommendations', []);\n\n// Status for display\nlet statusClass, statusIcon;\nswitch (decision) {\n    case 'PASS': statusClass = 'pass'; statusIcon = '✓'; break;\n    case 'REVIEW': statusClass = 'warning'; statusIcon = '⚠'; break;\n    case 'FAIL': statusClass = 'fail'; statusIcon = '✗'; break;\n    default: statusClass = 'unknown'; statusIcon = '?';\n}\n\n// Generate the complete HTML report\nconst htmlReport = `\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; line-height: 1.6; color: #333; }\n        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n        .header { text-align: center; border-bottom: 3px solid #007bff; padding-bottom: 20px; margin-bottom: 30px; }\n        .header h1 { color: #007bff; margin: 0; font-size: 28px; }\n        .status-pass { background: #d4edda; color: #155724; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-fail { background: #f8d7da; color: #721c24; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-warning { background: #fff3cd; color: #856404; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-unknown { background: #e2e3e5; color: #383d41; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 20px; }\n        .info-card { background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff; }\n        .info-card h4 { margin: 0 0 10px 0; color: #495057; font-size: 1.1em; border-bottom: 1px solid #ddd; padding-bottom: 5px; }\n        .info-card p { margin: 5px 0; font-size: 0.95em; word-wrap: break-word; }\n        table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 0.9em; }\n        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }\n        th { background: #e9ecef; font-weight: bold; color: #495057; }\n        .match { color: #28a745; font-weight: bold; }\n        .mismatch { color: #dc3545; font-weight: bold; }\n        .section { margin-bottom: 35px; }\n        .section h2, .section h3 { color: #007bff; border-bottom: 2px solid #e9ecef; padding-bottom: 8px; margin-bottom: 15px; font-size: 1.4em; }\n        .section h3 { font-size: 1.2em; }\n        .highlight { background: #e7f3ff; padding: 20px; border-radius: 8px; border-left: 5px solid #17a2b8; margin-top: 30px; }\n        .highlight h3 { color: #17a2b8; margin-top: 0; }\n        .warning-item, .error-item, .critical-item { padding: 10px; margin: 5px 0; border-radius: 4px; border-left-width: 5px; border-left-style: solid; }\n        .warning-item { background: #fff3cd; border-left-color: #ffeeba; }\n        .error-item { background: #f8d7da; border-left-color: #f5c6cb; }\n        .critical-item { background: #f8d7da; color: #721c24; font-weight: bold; border-left-color: #dc3545; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>📋 Document Validation Report</h1>\n            <div class=\"status-${statusClass}\">${statusIcon} ${decision}</div>\n            <p><strong>Date:</strong> ${new Date().toLocaleDateString('en-US')} | <strong>Status:</strong> ${overallStatus}</p>\n        </div>\n        \n        <div class=\"section\">\n            <h2>👤 Employee Information</h2>\n            <div class=\"info-card\">\n                <div class=\"info-grid\">\n                    <div><p><strong>Name:</strong> ${workerName}</p></div>\n                    <div><p><strong>Date of Birth:</strong> ${birthDate}</p></div>\n                    <div><p><strong>Age:</strong> ${age} years</p></div>\n                    <div><p><strong>Personal ID:</strong> ${personalId}</p></div>\n                    <div><p><strong>Nationality:</strong> ${nationality}</p></div>\n                    <div><p><strong>Profession:</strong> ${profession}</p></div>\n                </div>\n            </div>\n        </div>\n\n        <div class=\"section\">\n            <h3>📋 Document Status Overview</h3>\n            ${documentStatusHtml}\n        </div>\n\n        <div class=\"section\">\n            <h2>📄 Document Details</h2>\n            <div class=\"info-grid\">\n                ${documentDetailsHtml}\n            </div>\n        </div>\n        \n        <div class=\"section\">\n            <h3>🔍 Data Consistency</h3>\n            <table>\n                <tr><th>Field</th><th>Status</th></tr>\n                <tr><td>Name</td><td class=\"${consistency.name === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.name || 'N/A'}</td></tr>\n                <tr><td>Date of Birth</td><td class=\"${consistency.birthDate === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.birthDate || 'N/A'}</td></tr>\n                <tr><td>Personal ID</td><td class=\"${consistency.personalId === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.personalId || 'N/A'}</td></tr>\n                <tr><td>Nationality</td><td class=\"${consistency.nationality === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.nationality || 'N/A'}</td></tr>\n                <tr><td>Work Periods</td><td class=\"${crossConsistency.work_periods_align === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.work_periods_align || 'N/A'}</td></tr>\n                <tr><td>Employer</td><td class=\"${crossConsistency.employer_consistency === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.employer_consistency || 'N/A'}</td></tr>\n                <tr><td>Location</td><td class=\"${crossConsistency.location_consistency === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.location_consistency || 'N/A'}</td></tr>\n            </table>\n        </div>\n        \n        ${flags.length > 0 ? `\n        <div class=\"section\">\n            <h3>🚨 Issues & Warnings Found</h3>\n            ${flags.map(flag => `\n                <div class=\"${flag.type.toLowerCase()}-item\">\n                    <strong>${flag.type}:</strong> ${flag.message}\n                    ${flag.field ? `<em>(Field: ${flag.field})</em>` : ''}\n                </div>\n            `).join('')}\n        </div>\n        ` : ''}\n\n        ${recommendations.length > 0 ? `\n        <div class=\"highlight\">\n            <h3>💼 Recommendations</h3>\n            <ul>\n                ${recommendations.map(rec => `<li>${rec}</li>`).join('')}\n            </ul>\n        </div>\n        ` : ''}\n    </div>\n</body>\n</html>\n`;\n\n// Get all binary data (original documents)\nconst allBinaryAttachments = $input.first().binary || {};\n\n// Return the output\nreturn [{\n    json: {\n        html_report: htmlReport,\n        subject: `Document Validation - ${workerName} - ${decision}`,\n        worker_name: workerName,\n        decision: decision,\n        toEmail: getValue(inputData, 'originalEmail.from.address', 'fallback@email.com'),\n        validation_data_json: validationData\n    },\n    //binary: allBinaryAttachments\n    binary: $input.first().binary || {} \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        960
      ],
      "id": "9e92aa84-167d-4738-b495-b3732e43b6b9",
      "name": "mail template1"
    },
    {
      "parameters": {
        "jsCode": "\n\n// DYNAMIC AND ROBUST VERSION - Processes variable number of documents\nconst inputData = $input.first().json;\n\n// --- Helper Functions ---\nfunction getValue(obj, path, defaultValue = 'N/A') {\n    try {\n        const value = path.split('.').reduce((acc, key) => acc && acc[key], obj);\n        return value !== undefined && value !== null ? value : defaultValue;\n    } catch {\n        return defaultValue;\n    }\n}\n\nfunction formatArray(arr) {\n    if (Array.isArray(arr)) {\n        return arr.join(', ');\n    }\n    return arr || 'N/A';\n}\n\nfunction calculateAge(birthDate) {\n    if (!birthDate || birthDate === 'N/A') return 'N/A';\n    try {\n        // Tries DD/MM/YYYY and YYYY-MM-DD\n        let date;\n        if (birthDate.includes('/')) {\n            const parts = birthDate.split('/');\n            date = new Date(parts[2], parts[1] - 1, parts[0]);\n        } else if (birthDate.includes('-')) {\n            date = new Date(birthDate);\n        } else {\n            return 'N/A';\n        }\n        \n        const today = new Date();\n        let age = today.getFullYear() - date.getFullYear();\n        const m = today.getMonth() - date.getMonth();\n        if (m < 0 || (m === 0 && today.getDate() < date.getDate())) {\n            age--;\n        }\n        return isNaN(age) ? 'N/A' : age;\n    } catch {\n        return 'N/A';\n    }\n}\n\n// Function to generate HTML card for ANY document type - fully dynamic\nfunction renderDocumentCard(category, doc, index = 0) {\n    const data = doc || {};\n    \n    // Create human-readable title from category name\n    let baseTitle = category.replace(/_data$/, '').replace(/_/g, ' ')\n                           .replace(/\\b\\w/g, l => l.toUpperCase());\n    \n    // Add index if there are multiple documents of the same type\n    const title = index > 0 ? `${baseTitle} ${index + 1}` : baseTitle;\n    \n    // Special title mappings for common document types\n    const titleMappings = {\n        'Social Security': 'A1 Social Security Certificate',\n        'Identity Document': 'Identity Document',\n        'Work Notification': 'Work Notification',\n        'Safety Certificate': 'Safety Certificate',\n        'Professional Certificate': 'Professional Certificate',\n        'Training Certificate': 'Training Certificate'\n    };\n    \n    let finalTitle = titleMappings[baseTitle] || baseTitle;\n    \n    // Special handling for identity documents - show ID Card or Passport\n    if (category === 'identity_document_data' && data.document_type) {\n        const docType = data.document_type.toLowerCase();\n        if (docType.includes('passport')) {\n            finalTitle = index > 0 ? `Passport ${index + 1}` : 'Passport';\n        } else if (docType.includes('id') || docType.includes('identity')) {\n            finalTitle = index > 0 ? `ID Card ${index + 1}` : 'ID Card';\n        } else {\n            // Use the actual document type if available\n            finalTitle = index > 0 ? `${data.document_type} ${index + 1}` : data.document_type;\n        }\n    }\n    \n    // Generate details dynamically from all available fields\n    let details = '';\n    \n    // Define field display mappings and priorities\n    const fieldMappings = {\n        // Common fields\n        'document_type': 'Document Type',\n        'document_number': 'Document Number',\n        'certificate_number': 'Certificate Number',\n        'expiry_date': 'Expiry Date',\n        'issue_date': 'Issue Date',\n        'issuing_country': 'Issuing Country',\n        'issuing_authority': 'Issuing Authority',\n        \n        // Personal info\n        'worker_name': 'Worker Name',\n        'holder_name': 'Holder Name',\n        'employee_name': 'Employee Name',\n        'given_names': 'Given Names',\n        'surname': 'Surname',\n        'birth_date': 'Date of Birth',\n        'nationality': 'Nationality',\n        'gender': 'Gender',\n        'personal_identifier': 'Personal ID',\n        \n        // Work-related\n        'work_period_start': 'Work Period Start',\n        'work_period_end': 'Work Period End',\n        'sending_company': 'Sending Company',\n        'employer_name': 'Employer',\n        'work_location': 'Work Location',\n        'sector': 'Sector',\n        'profession': 'Profession',\n        'notification_country': 'Notification Country',\n        \n        // Certificate specific\n        'certificate_type': 'Certificate Type',\n        'issue_place': 'Issue Place',\n        'exam_language': 'Exam Language',\n        'validity_period': 'Validity Period',\n        'training_provider': 'Training Provider',\n        \n        // Additional\n        'director_manager': 'Director/Manager',\n        'receiving_companies': 'Receiving Companies'\n    };\n    \n    // Priority order for displaying fields\n    const fieldPriority = [\n        'document_type', 'certificate_type', 'document_number', 'certificate_number',\n        'worker_name', 'holder_name', 'employee_name', 'given_names', 'surname',\n        'work_period_start', 'work_period_end', 'expiry_date', 'issue_date',\n        'employer_name', 'sending_company', 'work_location', 'sector',\n        'issuing_country', 'issuing_authority', 'nationality', 'birth_date',\n        'personal_identifier', 'gender', 'profession', 'notification_country',\n        'issue_place', 'exam_language', 'director_manager', 'receiving_companies'\n    ];\n    \n    // Process fields in priority order first\n    for (const field of fieldPriority) {\n        if (data[field] !== undefined && data[field] !== null && data[field] !== '') {\n            const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            let value = data[field];\n            \n            // Format arrays nicely\n            if (Array.isArray(value)) {\n                value = formatArray(value);\n            }\n            \n            details += `<p><strong>${displayName}:</strong> ${value}</p>\\n                `;\n        }\n    }\n    \n    // Add any remaining fields not in priority list\n    for (const [field, value] of Object.entries(data)) {\n        if (!fieldPriority.includes(field) && \n            field !== 'additional_fields' && \n            value !== undefined && value !== null && value !== '') {\n            \n            const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            let displayValue = value;\n            \n            if (Array.isArray(displayValue)) {\n                displayValue = formatArray(displayValue);\n            } else if (typeof displayValue === 'object') {\n                // Skip complex objects for now\n                continue;\n            }\n            \n            details += `<p><strong>${displayName}:</strong> ${displayValue}</p>\\n                `;\n        }\n    }\n    \n    // Add additional_fields if they exist\n    if (data.additional_fields && typeof data.additional_fields === 'object') {\n        for (const [field, value] of Object.entries(data.additional_fields)) {\n            if (value !== undefined && value !== null && value !== '') {\n                const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                details += `<p><strong>${displayName}:</strong> ${value}</p>\\n                `;\n            }\n        }\n    }\n    \n    // If no details were generated, show a generic message\n    if (!details.trim()) {\n        details = '<p>No detailed information available for this document.</p>';\n    }\n    \n    return `<div class=\"info-card\"><h4>${finalTitle}</h4>${details}</div>`;\n}\n\n// --- Data Extraction ---\nconst decision = getValue(inputData, 'decision', 'UNKNOWN');\nconst overallStatus = getValue(inputData, 'overall_status', 'UNKNOWN');\nconst validationData = getValue(inputData, 'full_validation_report', {});\nconst firstReport = getValue(validationData, 'individual_reports.0', {});\n\n// Get all original document details\nconst originalDocs = getValue(firstReport, 'original_document_details', {});\n\n// Extract data objects/arrays for easy access - FULLY DYNAMIC\nconst personalData = getValue(firstReport, 'personal_data_comparison', {});\n\n// Create a flat array of ALL documents for easier searching\nconst allDocuments = [];\nfor (const [category, docData] of Object.entries(originalDocs)) {\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        documents.forEach(doc => {\n            if (doc) {\n                allDocuments.push({ category, ...doc });\n            }\n        });\n    }\n}\n\n// Dynamic employee information extraction - searches through ALL documents\nfunction findFieldInDocuments(fieldNames, fallback = 'N/A') {\n    // First try personal data comparison\n    for (const fieldName of fieldNames) {\n        const personalValue = getValue(personalData, `${fieldName}.social_security_doc`) ||\n                             getValue(personalData, `${fieldName}.identity_doc`) ||\n                             getValue(personalData, `${fieldName}.work_notification`);\n        if (personalValue && personalValue !== 'N/A') return personalValue;\n    }\n    \n    // Then search through all documents\n    for (const fieldName of fieldNames) {\n        for (const doc of allDocuments) {\n            if (doc[fieldName] && doc[fieldName] !== 'N/A') {\n                return doc[fieldName];\n            }\n        }\n    }\n    \n    // Special handling for combined names\n    if (fieldNames.includes('worker_name')) {\n        for (const doc of allDocuments) {\n            if (doc.given_names && doc.surname) {\n                return `${doc.given_names} ${doc.surname}`.trim();\n            }\n        }\n    }\n    \n    return fallback;\n}\n\nconst workerName = findFieldInDocuments(['worker_name', 'holder_name', 'employee_name', 'given_names']);\nconst birthDate = findFieldInDocuments(['birth_date']);\nconst personalId = findFieldInDocuments(['personal_identifier', 'employee_identification']);\nconst nationality = findFieldInDocuments(['nationality']);\nconst profession = findFieldInDocuments(['profession', 'sector']);\nconst age = calculateAge(birthDate);\n\n// Document status - DYNAMIC based on what's actually present\nconst mandatoryDocs = getValue(firstReport, 'mandatory_documents_check', {});\n\n// Create dynamic document status overview\nlet documentStatusHtml = '';\nconst documentCounts = {};\n\n// Count all document types\nfor (const category in originalDocs) {\n    const docData = originalDocs[category];\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        const validDocs = documents.filter(doc => doc && Object.keys(doc).length > 0);\n        if (validDocs.length > 0) {\n            documentCounts[category] = validDocs.length;\n        }\n    }\n}\n\n// Generate status for each document type found\nfor (const [category, count] of Object.entries(documentCounts)) {\n    const displayName = category.replace(/_data$/, '').replace(/_/g, ' ')\n                               .replace(/\\b\\w/g, l => l.toUpperCase());\n    const status = count > 0 ? '✓ Present' : '✗ Missing';\n    const countText = count > 1 ? ` (${count} documents)` : '';\n    documentStatusHtml += `<p><strong>${displayName}:</strong> ${status}${countText}</p>\\n            `;\n}\n\n// Also check mandatory document status if available\nconst mandatoryStatusMapping = {\n    'social_security_document_present': 'Social Security Document',\n    'identity_document_present': 'Identity Document', \n    'work_notification_present': 'Work Notification',\n    'safety_certificate_present': 'Safety Certificate',\n    'professional_certificate_present': 'Professional Certificate'\n};\n\nfor (const [key, displayName] of Object.entries(mandatoryStatusMapping)) {\n    if (mandatoryDocs[key] !== undefined) {\n        // Only show if not already covered by document counts\n        const category = displayName.toLowerCase().replace(/\\s+/g, '_') + '_data';\n        if (!documentCounts[category]) {\n            const status = mandatoryDocs[key] === 'YES' ? '✓ Present' : '✗ Missing';\n            documentStatusHtml += `<p><strong>${displayName}:</strong> ${status}</p>\\n            `;\n        }\n    }\n}\n\n// --- Dynamic HTML Generation ---\n\n// Generate HTML for all document cards - FULLY DYNAMIC with identity documents first\nlet documentDetailsHtml = '';\n\n// First, render identity documents (ID cards/passports) at the top\nif (originalDocs['identity_document_data']) {\n    const identityData = originalDocs['identity_document_data'];\n    const identityDocuments = Array.isArray(identityData) ? identityData : [identityData];\n    \n    identityDocuments.forEach((doc, index) => {\n        if (doc && Object.keys(doc).length > 0) {\n            documentDetailsHtml += renderDocumentCard('identity_document_data', doc, index);\n        }\n    });\n}\n\n// Then render all other document types\nfor (const category in originalDocs) {\n    // Skip identity documents as they're already rendered\n    if (category === 'identity_document_data') continue;\n    \n    const docData = originalDocs[category];\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        \n        documents.forEach((doc, index) => {\n            if (doc && Object.keys(doc).length > 0) {\n                documentDetailsHtml += renderDocumentCard(category, doc, index);\n            }\n        });\n    }\n}\n\n// Consistency checks\nconst consistency = {\n    name: getValue(personalData, 'name.status', 'UNKNOWN'),\n    birthDate: getValue(personalData, 'birth_date.status', 'UNKNOWN'),\n    personalId: getValue(personalData, 'personal_identifier.status', 'UNKNOWN'),\n    nationality: getValue(personalData, 'nationality.status', 'UNKNOWN')\n};\nconst crossConsistency = getValue(firstReport, 'cross_document_consistency', {});\n\n// Flags, warnings and recommendations\nconst flags = getValue(validationData, 'flags_and_warnings', []);\nconst recommendations = getValue(validationData, 'recommendations', []);\n\n// Status for display\nlet statusClass, statusIcon;\nswitch (decision) {\n    case 'PASS': statusClass = 'pass'; statusIcon = '✓'; break;\n    case 'REVIEW': statusClass = 'warning'; statusIcon = '⚠'; break;\n    case 'FAIL': statusClass = 'fail'; statusIcon = '✗'; break;\n    default: statusClass = 'unknown'; statusIcon = '?';\n}\n\n// Generate the complete HTML report\nconst htmlReport = `\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; line-height: 1.6; color: #333; }\n        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n        .header { text-align: center; border-bottom: 3px solid #007bff; padding-bottom: 20px; margin-bottom: 30px; }\n        .header h1 { color: #007bff; margin: 0; font-size: 28px; }\n        .status-pass { background: #d4edda; color: #155724; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-fail { background: #f8d7da; color: #721c24; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-warning { background: #fff3cd; color: #856404; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-unknown { background: #e2e3e5; color: #383d41; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 20px; }\n        .info-card { background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff; }\n        .info-card h4 { margin: 0 0 10px 0; color: #495057; font-size: 1.1em; border-bottom: 1px solid #ddd; padding-bottom: 5px; }\n        .info-card p { margin: 5px 0; font-size: 0.95em; word-wrap: break-word; }\n        table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 0.9em; }\n        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }\n        th { background: #e9ecef; font-weight: bold; color: #495057; }\n        .match { color: #28a745; font-weight: bold; }\n        .mismatch { color: #dc3545; font-weight: bold; }\n        .section { margin-bottom: 35px; }\n        .section h2, .section h3 { color: #007bff; border-bottom: 2px solid #e9ecef; padding-bottom: 8px; margin-bottom: 15px; font-size: 1.4em; }\n        .section h3 { font-size: 1.2em; }\n        .highlight { background: #e7f3ff; padding: 20px; border-radius: 8px; border-left: 5px solid #17a2b8; margin-top: 30px; }\n        .highlight h3 { color: #17a2b8; margin-top: 0; }\n        .warning-item, .error-item, .critical-item { padding: 10px; margin: 5px 0; border-radius: 4px; border-left-width: 5px; border-left-style: solid; }\n        .warning-item { background: #fff3cd; border-left-color: #ffeeba; }\n        .error-item { background: #f8d7da; border-left-color: #f5c6cb; }\n        .critical-item { background: #f8d7da; color: #721c24; font-weight: bold; border-left-color: #dc3545; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>📋 Document Validation Report</h1>\n            <div class=\"status-${statusClass}\">${statusIcon} ${decision}</div>\n            <p><strong>Date:</strong> ${new Date().toLocaleDateString('en-US')} | <strong>Status:</strong> ${overallStatus}</p>\n        </div>\n        \n        <div class=\"section\">\n            <h2>👤 Employee Information</h2>\n            <div class=\"info-card\">\n                <div class=\"info-grid\">\n                    <div><p><strong>Name:</strong> ${workerName}</p></div>\n                    <div><p><strong>Date of Birth:</strong> ${birthDate}</p></div>\n                    <div><p><strong>Age:</strong> ${age} years</p></div>\n                    <div><p><strong>Personal ID:</strong> ${personalId}</p></div>\n                    <div><p><strong>Nationality:</strong> ${nationality}</p></div>\n                    <div><p><strong>Profession:</strong> ${profession}</p></div>\n                </div>\n            </div>\n        </div>\n\n        <div class=\"section\">\n            <h3>📋 Document Status Overview</h3>\n            ${documentStatusHtml}\n        </div>\n\n        <div class=\"section\">\n            <h2>📄 Document Details</h2>\n            <div class=\"info-grid\">\n                ${documentDetailsHtml}\n            </div>\n        </div>\n        \n        <div class=\"section\">\n            <h3>🔍 Data Consistency</h3>\n            <table>\n                <tr><th>Field</th><th>Status</th></tr>\n                <tr><td>Name</td><td class=\"${consistency.name === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.name || 'N/A'}</td></tr>\n                <tr><td>Date of Birth</td><td class=\"${consistency.birthDate === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.birthDate || 'N/A'}</td></tr>\n                <tr><td>Personal ID</td><td class=\"${consistency.personalId === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.personalId || 'N/A'}</td></tr>\n                <tr><td>Nationality</td><td class=\"${consistency.nationality === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.nationality || 'N/A'}</td></tr>\n                <tr><td>Work Periods</td><td class=\"${crossConsistency.work_periods_align === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.work_periods_align || 'N/A'}</td></tr>\n                <tr><td>Employer</td><td class=\"${crossConsistency.employer_consistency === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.employer_consistency || 'N/A'}</td></tr>\n                <tr><td>Location</td><td class=\"${crossConsistency.location_consistency === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.location_consistency || 'N/A'}</td></tr>\n            </table>\n        </div>\n        \n        ${flags.length > 0 ? `\n        <div class=\"section\">\n            <h3>🚨 Issues & Warnings Found</h3>\n            ${flags.map(flag => `\n                <div class=\"${flag.type.toLowerCase()}-item\">\n                    <strong>${flag.type}:</strong> ${flag.message}\n                    ${flag.field ? `<em>(Field: ${flag.field})</em>` : ''}\n                </div>\n            `).join('')}\n        </div>\n        ` : ''}\n\n        ${recommendations.length > 0 ? `\n        <div class=\"highlight\">\n            <h3>💼 Recommendations</h3>\n            <ul>\n                ${recommendations.map(rec => `<li>${rec}</li>`).join('')}\n            </ul>\n        </div>\n        ` : ''}\n    </div>\n</body>\n</html>\n`;\n\n// Get all binary data (original documents)\nconst allBinaryAttachments = $input.first().binary || {};\n\n// Return the output\nreturn [{\n    json: {\n        html_report: htmlReport,\n        subject: `Document Validation - ${workerName} - ${decision}`,\n        worker_name: workerName,\n        decision: decision,\n        toEmail: getValue(inputData, 'originalEmail.from.address', 'fallback@email.com'),\n        validation_data_json: validationData\n    },\n    //binary: allBinaryAttachments\n    binary: $input.first().binary || {} \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        496,
        400
      ],
      "id": "f71d9d20-2882-4761-a531-1d980f0a34c7",
      "name": "mail template"
    },
    {
      "parameters": {
        "fromEmail": "ai@go-knowledge.nl",
        "toEmail": "={{ $('On form submission').item.json.Mail }}",
        "subject": "Failure Subcontracter screening ",
        "html": "={{ $json.html_report }}",
        "options": {
          "appendAttribution": false,
          "attachments": "={{ Object.keys($binary).join(\",\") }}"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        1040,
        480
      ],
      "id": "1d739e0e-6e5a-4bf4-b969-f6ff537dad1a",
      "name": "Send Email1",
      "webhookId": "72b63045-27e2-4305-9aef-76f16ca3b1b2",
      "credentials": {
        "smtp": {
          "id": "yG4Ihfi7vhKZzG49",
          "name": "ai@go-knowledge"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "40c2daca-0a33-46ea-b3c7-7ef41f9a4c56",
              "leftValue": "={{ $json.decision }}",
              "rightValue": "PASS",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        704,
        416
      ],
      "id": "e6ef18e9-9b0b-4eca-93ab-dc22f44aa42b",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "const results = [];\nconst inputItems = $input.all();\n\nfor (const item of inputItems) {\n  if (item.binary) {\n    for (const [key, bin] of Object.entries(item.binary)) {\n      const fileName = bin.fileName?.toLowerCase() || '';\n      const mimeType = bin.mimeType?.toLowerCase() || '';\n\n      const isAttachment = key.startsWith('attachment_') || \n                           key.includes('attachment') || \n                           key.startsWith('data_') ||\n                           bin.fileName;\n\n      // Herkenbare extensies\n      const isPdf = mimeType === 'application/pdf' || fileName.endsWith('.pdf');\n      const isJpg = mimeType === 'image/jpeg' || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg');\n      const isPng = mimeType === 'image/png' || fileName.endsWith('.png');\n\n      const isAllowedFile = isPdf || isJpg || isPng;\n\n      if (isAttachment && isAllowedFile) {\n        results.push({\n          binary: {\n            data: bin,\n          },\n          json: {\n            fileName: bin.fileName || `attachment_${key}`,\n            mimeType: bin.mimeType || 'unknown',\n            originalKey: key,\n          },\n        });\n      }\n    }\n  }\n}\n\nreturn results.length > 0 ? results : [{\n  json: {\n    error: 'Geen PDF of afbeeldingsbestanden gevonden',\n    tip: 'Controleer of er PDF/JPG/PNG-bijlagen in de e-mail zitten en of de e-mail correct is verwerkt'\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2032,
        464
      ],
      "id": "c18392d0-b7a8-4c43-9195-3c45ba03353a",
      "name": "Extract Attachments2",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Information regarding signatures or stamps must be returned/included with validation_date - this information is included in the accompanying data that I am providing.  = {{ $json.validation_date }}\n\n{{ $json.combined_documents }}",
        "options": {
          "systemMessage": "=You will receive multiple JSON documents for the same person from ANY European Union country. Perform strict cross-document validation and create a comprehensive validation report with ALL document details.\n\n## **MANDATORY DOCUMENTS (ALL REQUIRED):**\n\n- A1/Social Security Certificate (EU regulation 883/2004) OR equivalent national document\n- National Identity Card OR Passport\n- Work Notification (Limosa/A1/National equivalent) \n- Safety/Professional Certificate (VCA/DGUV/National equivalent)\n\n## **EUROPEAN DOCUMENT VARIATIONS:**\n\n- **Identity:** ID Card, Passport, National Identity Document\n- **Personal Numbers:** BSN (NL), PESEL (PL), Personal Code (LT), Social Security Number, etc.\n- **Work Permits:** A1, A28, Limosa, National work declarations\n- **Safety Certs:** VCA (NL/BE), DGUV (DE), National safety certificates\n\n## **PERSONAL IDENTIFIER VALIDATION LOGIC:**\n\n- **Primary Goal:** Do NOT compare personal identifiers of different types (e.g., a national personal code vs. an administrative work number). Treat them as separate pieces of information.\n\n- **RULE 1: Group and Compare Like-Types:**\n  - Identify all instances of a **national personal identifier**.\n  - Compare these identifiers ONLY with each other. If they are all identical, report their status as `MATCH`.\n\n- **RULE 2: Isolate and Report Other Types:**\n  - Identify all instances of **administrative work numbers**.\n  - Do NOT compare these numbers with any other type of identifier. Report their status simply as `PRESENT`.\n\n- **ACTION:** The final output must be a summary object that lists each unique type of identifier found, its value, its own comparison status (`MATCH`, `MISMATCH`, or `PRESENT`), and the source documents.\n\n## **CRITICAL VALIDATION RULES:**\n\n- If ANY of the 4 mandatory document types is missing → overall_status = \"FAIL\"\n- **If ANY document is expired as of the determined validation date → overall_status = \"FAIL\"**\n- **If A1/social security work period has ended relative to the determined validation date → overall_status = \"FAIL\"**\n- **If safety certificate is expired relative to the determined validation date → overall_status = \"FAIL\"**\n- **If identity document is expired relative to the determined validation date → overall_status = \"FAIL\"**\n- **If work notification period has ended relative to the determined validation date → overall_status = \"FAIL\"**\n- Compare personal data across all documents (accounting for different formats)\n- Check for inconsistencies in names, dates, numbers\n- Verify document validity periods overlap with work periods, considering **future start dates are permissible if the document is formally submitted/issued at or before the determined validation date**.\n- **ALL documents must be currently valid as per their submission/issue date on or before the determined validation date, and their validity period must cover any relevant work period starting from or after the determined validation date.**\n- Flag suspicious patterns\n- PRESERVE ALL original document details regardless of country format\n\n\n## **MANDATORY FAILURE CONDITIONS:**\n\n- **Missing social security/A1 equivalent → FAIL**\n- **Missing identity document → FAIL** - **Missing work notification → FAIL**\n- **Missing safety certificate → FAIL**\n- **ANY document expired as of the determined validation date → FAIL**\n- **A1/Social security certificate work period ended relative to the determined validation date → FAIL**\n- **Safety certificate expired relative to the determined validation date → FAIL**\n- **Identity document expired relative to the determined validation date → FAIL**\n- **Work notification period ended relative to the determined validation date → FAIL**\n- Documents expired during work period relative to the determined validation date → FAIL\n- Non-EU citizen without proper work authorization → FAIL\n- **The determined validation date falls outside any document's overall submission/validity timeframe. For work-specific documents (A1, Work Notification), if their formal 'sent' or 'issue date' is *after* the determined validation date, it's a FAIL.**\n\n## **DATE VALIDATION REQUIREMENTS:**\n\n1.  **Determine Validation Date:** The AI must first establish a 'validation_date'.\n    * If a 'validation_date' is explicitly provided in the input, use that.\n    * Otherwise, the AI must infer the 'validation_date' as the **earliest 'notification sent on' or 'issue date'** (e.g., Limosa 'Melding verstuurd op', A1 application date) across all provided *work authorization related documents*.\n    * If no such 'notification sent on' or 'issue date' can be inferred, then use the **earliest 'work_period_start' date** from either the A1/Social Security Certificate or the Work Notification (Limosa/National equivalent) across all provided documents.\n    * If no suitable date can be inferred from the documents, the AI should use the **current actual date** as the 'validation_date'.\n    * **Crucially, if an A1 certificate application is provided and is signed, the AI must consider the worker eligible to commence work from its stated 'work_period_start' date, leading to a 'WARNING' status if the final certificate is pending, rather than a 'FAIL' due to the absence of the final A1 certificate itself.**\n2. **Check validity against determined validation date:** Compare ALL expiry dates and work periods against the *determined validation date*.\n2a. For Romanian identity documents, extract the date of birth from the CNP (Cod Numeric Personal).\nThe CNP format is: S YY MM DD XXXXX C, where:\nS indicates gender and century (1 or 2 = born 1900–1999, 5 or 6 = born 2000–2099; odd = male, even = female),\nYYMMDD is the date of birth.\nFor example, a CNP of 1990124046252 represents a birth date of 1999-01-24.\nUse this to validate birth date consistency across documents and to calculate age as of the determined validation date.\n3. **No grace periods:** Documents must be valid on the exact *determined validation date* (for expiry) or their submission/issue date must be on or before the *determined validation date*.\n4. **Work authorization current:** A1/social security work period must include or extend beyond *determined validation date* OR its formal validity starts after the determined validation date but is adequately submitted/issued.\n5. **Safety certification current:** Safety certificate must not be expired relative to the *determined validation date*.\n6. **Identity document current:** Passport/ID must not be expired relative to the *determined validation date*.\n\n## **OUTPUT FORMAT:**\n\n```json\n{\n  \"validation_summary\": {\n    \"overall_status\": \"PASS/WARNING/FAIL\",\n    \"documents_validated\": [\"[Document Type 1]\", \"[Document Type 2]\", \"[Document Type 3]\", \"[Document Type 4]\"],\n    \"validation_date\": \"[determined validation date]\",\n    \"worker_nationality\": \"[nationality]\",\n    \"destination_country\": \"[work destination]\"\n  },\n  \"mandatory_documents_check\": {\n    \"social_security_document_present\": \"YES/NO\",\n    \"identity_document_present\": \"YES/NO\", \n    \"work_notification_present\": \"YES/NO\",\n    \"safety_certificate_present\": \"YES/NO\",\n    \"all_mandatory_present\": \"YES/NO\"\n  },\n  \"personal_data_comparison\": {\n    \"name\": {\n      \"social_security_doc\": \"[name from social security doc]\",\n      \"identity_doc\": \"[name from identity doc]\", \n      \"work_notification\": \"[name from work notification]\",\n      \"safety_certificate\": \"[name from safety cert]\",\n      \"status\": \"MATCH/MISMATCH\",\n      \"issues\": \"[any issues found]\"\n    },\n    \"birth_date\": {\n      \"social_security_doc\": \"[date]\",\n      \"identity_doc\": \"[date]\",\n      \"safety_certificate\": \"[date if available]\",\n      \"status\": \"MATCH/MISMATCH\"\n    },\n    \"personal_identifier\": {\n      \"social_security_doc\": \"[personal number/code/BSN/PESEL/etc]\", \n      \"identity_doc\": \"[personal number/code/BSN/PESEL/etc]\",\n      \"type\": \"[BSN/PESEL/Personal Code/Social Security Number/etc]\",\n      \"status\": \"MATCH/MISMATCH\"\n    },\n    \"nationality\": {\n      \"social_security_doc\": \"[nationality]\",\n      \"identity_doc\": \"[nationality]\", \n      \"status\": \"MATCH/MISMATCH\"\n    }\n  },\n  \"document_validity_check\": {\n    \"identity_document_expiry\": \"[date]\",\n    \"safety_certificate_expiry\": \"[date]\",\n    \"work_period_end\": \"[date]\",\n    \"validity_status\": \"VALID/EXPIRED/EXPIRING_SOON\"\n  },\n  \"original_document_details\": {\n    \"social_security_data\": {\n      \"document_type\": \"[A1/A28/National equivalent]\",\n      \"worker_name\": \"[full name]\",\n      \"birth_date\": \"[date]\",\n      \"personal_identifier\": \"[BSN/PESEL/Personal Code/etc]\",\n      \"nationality\": \"[nationality]\",\n      \"work_period_start\": \"[start date]\",\n      \"work_period_end\": \"[end date]\",\n      \"sending_company\": \"[company name]\",\n      \"receiving_companies\": [\"[list of companies]\"],\n      \"director_manager\": \"[director/manager name]\",\n      \"profession\": \"[job title]\",\n      \"issuing_country\": \"[country]\",\n      \"additional_fields\": {\n        \"stamp_present\": true,\n        \"stamp_confidence\": 0.9,\n        \"signature_present\": true,\n        \"signature_confidence\": 0.7,\n        \"luik_3_2_checked\": true,\n        \"luik_4_1_1_checked\": false,\n        \"[any other fields found]\": \"[values]\"\n      }\n    },\n    \"identity_document_data\": {\n      \"document_type\": \"[ID Card/Passport/National ID]\",\n      \"surname\": \"[surname]\",\n      \"given_names\": \"[given names]\",\n      \"birth_date\": \"[date]\",\n      \"personal_identifier\": \"[document number/BSN/PESEL/etc]\",\n      \"nationality\": \"[nationality]\",\n      \"document_number\": \"[ID/passport number]\",\n      \"expiry_date\": \"[expiry date]\",\n      \"gender\": \"[M/F]\",\n      \"issuing_country\": \"[country]\",\n      \"issuing_authority\": \"[authority]\",\n      \"additional_fields\": {\n        \"stamp_present\": true,\n        \"stamp_confidence\": 0.9,\n        \"signature_present\": true,\n        \"signature_confidence\": 0.9,\n        \"[any other fields found]\": \"[values]\"\n      }\n    },\n    \"work_notification_data\": {\n      \"document_type\": \"[Limosa/A1/National work notification]\",\n      \"employee_name\": \"[name]\",\n      \"work_period_start\": \"[start date]\",\n      \"work_period_end\": \"[end date]\", \n      \"employer_name\": \"[employer]\",\n      \"employer_address\": \"[address]\",\n      \"work_location\": \"[work location]\",\n      \"sector\": \"[work sector]\",\n      \"notification_country\": \"[country]\",\n      \"employee_identification\": \"[various ID numbers]\",\n      \"additional_fields\": {\n        \"stamp_present\": false,\n        \"stamp_confidence\": 0.0,\n        \"signature_present\": false,\n        \"signature_confidence\": 0.0,\n        \"[any other fields found]\": \"[values]\"\n      }\n    },\n    \"safety_certificate_data\": {\n      \"document_type\": \"[VCA/DGUV/National safety certificate]\",\n      \"holder_name\": \"[name]\",\n      \"birth_date\": \"[date]\",\n      \"certificate_number\": \"[certificate number]\",\n      \"certificate_type\": \"[specific type/level]\",\n      \"expiry_date\": \"[expiry date]\",\n      \"issue_place\": \"[issuing location]\",\n      \"issuing_country\": \"[country]\",\n      \"exam_language\": \"[language]\",\n      \"validity_scope\": \"[where valid]\",\n      \"additional_fields\": {\n        \"stamp_present\": true,\n        \"stamp_confidence\": 0.9,\n        \"signature_present\": true,\n        \"signature_confidence\": 0.7,\n        \"[any other fields found]\": \"[values]\"\n      }\n    }\n  },\n  \"cross_document_consistency\": {\n    \"work_periods_align\": \"YES/NO/PARTIAL\",\n    \"employer_consistency\": \"YES/NO\", \n    \"location_consistency\": \"YES/NO\",\n    \"eu_regulation_compliance\": \"YES/NO/PARTIAL\"\n  },\n  \"flags_and_warnings\": [\n    {\n      \"type\": \"WARNING/ERROR/CRITICAL\",\n      \"field\": \"[field name]\",\n      \"message\": \"[description of issue]\",\n      \"country_specific\": \"[if country-specific issue]\"\n    }\n  ],\n  \"recommendations\": [\n    \"[list of recommended actions]\"\n  ]\n}\nINSTRUCTIONS:\nFIRST: Determine the 'validation_date':\n\nIf the user explicitly provides a 'validation_date' in their input (e.g., \"Validate as of YYYY-MM-DD\"), use that date.\n\nOtherwise, the AI must infer the 'validation_date' as the earliest 'notification sent on' date (e.g., Limosa 'Melding verstuurd op', A1 application date/submission date, or similar formal issue date) found across all provided work authorization related documents. This date represents when the formal process began.\n\nIf no such 'notification sent on' or 'issue date' can be inferred, then use the earliest 'work_period_start' date from either the A1/Social Security Certificate or the Work Notification (Limosa/National equivalent) across all provided documents.\n\nIf no suitable date can be inferred from the documents, the AI should use the current actual date as the 'validation_date'.\n\nCrucially, if an A1 certificate application is provided and is signed, the AI must consider the worker eligible to commence work from its stated 'work_period_start' date, leading to a 'WARNING' status if the final certificate is pending, rather than a 'FAIL' due to the absence of the final A1 certificate itself.\n\nSECOND: Immediately check ALL expiry dates and work periods against the determined 'validation_date' AND the specific document's 'work_period_start' if it's in the future.\n\nAdapt field extraction based on country-specific formats\n\nCheck if all 4 mandatory document TYPES are present (regardless of exact names)\n\nVERIFY ALL DOCUMENTS ARE CURRENTLY VALID relative to the determined 'validation_date'. This means the document's expiry must be after 'validation_date', and for documents with a 'notification sent on' or 'issue date', this date must be on or before 'validation_date'. NO TOLERANCE FOR EXPIRED DOCUMENTS.\n\nEXTRACT AND PRESERVE ALL DETAILS from each document, including country-specific fields.\n\nCompare identical data across documents accounting for format differences.\n\nCheck EU work authorization validity and compliance. Specifically, verify if a signed application for an A1 certificate is provided. If so, and if this condition permits the worker to legally commence work according to EU or national regulations (which the AI must verify), issue a 'WARNING' status instead of a 'FAIL' for the social security document, if the final A1 certificate is not yet issued.\n\nFlag country-specific compliance issues.\n\nProvide clear PASS/WARNING/FAIL status.\n\nInformation regarding signatures or stamps must be returned/included with validation_date - this information is included in the accompanying data that I am providing. Additionally, information about checked boxes (particularly Luik 3.2 and Luik 4.1.1 in A1 forms) must also be returned in true/false format: return true only if the checkbox is actually checked/marked in the document, return false if the checkbox is not checked or not found. Do not interpret or modify any information about stamps, signatures, or checkboxes - return exactly what is present in the original documents.\n\nCRITICAL ADAPTATIONS:\nPersonal Identifiers: BSN (NL), PESEL (PL), Personal Code (LT), Social Security Number (various)\n\nDocument Names: A1/A28 (EU), Limosa (BE/NL), National work permits\n\nSafety Certificates: VCA (NL/BE), DGUV (DE), National equivalents\n\nName Formats: Account for different European naming conventions\n\nDate Formats: DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD variations\n\nEUROPEAN-SPECIFIC CHECKS:\nEU regulation 883/2004 compliance for social security coordination\n\nPosting worker directive compliance\n\nCountry-specific work notification requirements\n\nProfessional qualification recognition (where applicable)\n\nLanguage requirements for safety certificates\n\nIMPORTANT: - This system must work for workers from ANY EU country working in ANY other EU country.\nExtract ALL available information regardless of country-specific formatting.\n\nPreserve original field names alongside standardized interpretations.\n\nNO EXCEPTIONS FOR EXPIRED DOCUMENTS - ALL MUST BE CURRENTLY VALID relative to the determined 'validation_date'.\n\nZERO TOLERANCE FOR EXPIRED WORK AUTHORIZATION (unless a valid, signed A1 application is confirmed to permit work commencement, leading to a 'WARNING' as per instruction 8).\n\nA document's 'work_period_start' being in the future relative to the 'validation_date' is acceptable IF the document's 'notification sent on' or 'issue date' is on or before the 'validation_date', indicating a valid future authorization.\n\nValidation_date cannot possibly be 2024; it can only be today's date. Any attempt to give it a different date is an error on your part and must be corrected before submitting the answer.",
          "passthroughBinaryImages": "={{ true }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        -240,
        400
      ],
      "id": "61973d87-789a-464e-a4da-867831d46937",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "c231ae42-f532-4058-b1c8-eaa599f26d2c",
              "leftValue": "={{ $json.mimeType }}",
              "rightValue": "image/png",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "ceacc451-4c5f-473b-90bf-b0b0a90ffea9",
              "leftValue": "={{ $json.mimeType }}",
              "rightValue": "image/jpg",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1824,
        464
      ],
      "id": "961013cb-a01a-4009-8979-825479c65220",
      "name": "If1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://pdfmaker.reffey.nl/forms/libreoffice/convert",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1664,
        80
      ],
      "id": "a322d59a-d7b4-4424-8b2f-450c6101b9f7",
      "name": "HTTP Request"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1456,
        464
      ],
      "id": "2e3d25c0-1401-4d5b-9d7d-4f32aff3b1b3",
      "name": "Merge"
    },
    {
      "parameters": {
        "fromEmail": "ai@go-knowledge.nl",
        "toEmail": "={{ $('On form submission').item.json.Mail }}",
        "subject": "=AI validation check : {{ $json.worker_name }}",
        "html": "={{ $json.html_report }}",
        "options": {
          "appendAttribution": false,
          "attachments": "={{ Object.keys($binary).join(\",\") }}"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        1040,
        288
      ],
      "id": "45ffe97d-8d91-4b8d-9755-6f413fa0a9b9",
      "name": "Send email",
      "webhookId": "1f7e2d12-8eed-459f-8d0e-b8c4d82b0d34",
      "notesInFlow": true,
      "alwaysOutputData": true,
      "credentials": {
        "smtp": {
          "id": "yG4Ihfi7vhKZzG49",
          "name": "ai@go-knowledge"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "71f6e5a1-bcf0-48ed-985b-6ee248191ddb",
              "leftValue": "={{ $json.candidates[0].content.parts[0].text }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "1e9126e0-fc1c-4537-9066-85252bc7ff29",
              "leftValue": "={{ $json.candidates[0].content.parts[0].text }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1104,
        1072
      ],
      "id": "26b94546-c9d5-429e-a478-69c95a827952",
      "name": "If2"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\n\nreturn [\n  {\n    json: {\n      debug_preview: input\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        1088
      ],
      "id": "a12b7f6b-dbd0-47e3-9e27-e5b7f637a5dd",
      "name": "Code1"
    },
    {
      "parameters": {
        "jsCode": "// JSON data ophalen uit de vorige node\nconst jsonData = $input.first().json;\n\n/**\n * Helper functie om veilig waarden uit nested objecten te halen\n */\nfunction getValue(obj, path, defaultValue = 'N/A') {\n    try {\n        const value = path.split('.').reduce((acc, key) => acc && acc[key], obj);\n        return value !== undefined && value !== null ? value : defaultValue;\n    } catch {\n        return defaultValue;\n    }\n}\n\n/**\n * Zoekt door alle documenten naar een specifiek veld\n */\nfunction findInAllDocuments(documents, fieldNames) {\n    for (const fieldName of fieldNames) {\n        for (const doc of documents) {\n            if (doc[fieldName] && doc[fieldName] !== 'N/A') {\n                return doc[fieldName];\n            }\n        }\n    }\n    return 'N/A';\n}\n\n/**\n * Extraheert ALLE nuttige data uit het complexe JSON-object in een specifieke volgorde.\n */\nfunction extractAllData(data) {\n    const report = data.full_validation_report?.individual_reports?.[0] || data.full_validation_report || data;\n    const validation = data.full_validation_report?.validation_summary || report.validation_summary || {};\n    const originalDocs = report.original_document_details || {};\n    \n    const allDocuments = [];\n    for (const [category, docData] of Object.entries(originalDocs)) {\n        if (docData) {\n            const documents = Array.isArray(docData) ? docData : [docData];\n            documents.forEach(doc => {\n                if (doc) {\n                    allDocuments.push({ category, ...doc });\n                }\n            });\n        }\n    }\n    \n    const tempDocs = {};\n    \n    for (const [category, docData] of Object.entries(originalDocs)) {\n        if (!docData) continue;\n        \n        const documents = Array.isArray(docData) ? docData : [docData];\n        \n        documents.forEach((doc, index) => {\n            if (!doc || Object.keys(doc).length === 0) return;\n            \n            let categoryName = category.replace(/_data$/, '').replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            \n            if (category.includes('identity_document') || category.includes('passport')) {\n                categoryName = 'ID Card / Passport';\n            } else if (category.includes('social_security_data')) {\n                categoryName = 'A1';\n            } else if (category.includes('work_notification')) {\n                categoryName = 'Limosa';\n            } else if (category.includes('safety_certificate_data')) {\n                categoryName = 'VCA / SCC';\n            }\n            \n            const prefix = documents.length > 1 ? `${categoryName} ${index + 1}` : categoryName;\n            \n            tempDocs[prefix] = {};\n            \n            const priorityFields = [\n                'document_type', 'certificate_type', 'document_number', 'certificate_number',\n                'given_names', 'surname', 'worker_name', 'holder_name', 'employee_name',\n                'birth_date', 'nationality', 'gender', 'personal_identifier',\n                'work_period_start', 'work_period_end', 'expiry_date', 'issue_date',\n                'employer_name', 'sending_company', 'work_location', 'sector',\n                'issuing_country', 'issuing_authority', 'notification_country', 'firm_issuing', 'issue_place', 'basis_of_vol'\n            ];\n            \n            for (const field of priorityFields) {\n                if (doc[field] !== undefined && doc[field] !== null && doc[field] !== '') {\n                    const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                    tempDocs[prefix][`${prefix}_${displayName}`] = doc[field];\n                }\n            }\n            \n            for (const [field, value] of Object.entries(doc)) {\n                if (priorityFields.includes(field) || field === 'additional_fields' || value === undefined || value === null || value === '') {\n                    continue;\n                }\n                \n                let displayValue = value;\n                if (Array.isArray(displayValue)) {\n                    displayValue = displayValue.join(', ');\n                } else if (typeof displayValue === 'object') {\n                    continue;\n                }\n                \n                const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                tempDocs[prefix][`${prefix}_${displayName}`] = displayValue;\n            }\n            \n            if (doc.stamp_present !== undefined) {\n                tempDocs[prefix][`${prefix}_Stamp_Present`] = doc.stamp_present ? 'YES' : 'NO';\n            }\n            if (doc.signature_present !== undefined) {\n                tempDocs[prefix][`${prefix}_Signature_Present`] = doc.signature_present ? 'YES' : 'NO';\n            }\n            \n            if (doc.additional_fields && typeof doc.additional_fields === 'object') {\n                for (const [field, value] of Object.entries(doc.additional_fields)) {\n                    if (field.includes('_confidence')) continue;\n                    \n                    if (value !== undefined && value !== null && value !== '') {\n                        let displayValue = value;\n                        if (typeof value === 'boolean') {\n                            displayValue = value ? 'YES' : 'NO';\n                        }\n                        \n                        const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                        tempDocs[prefix][`${prefix}_${displayName}`] = displayValue;\n                    }\n                }\n            }\n        });\n    }\n\n    const orderedData = {};\n\n    const idDocs = Object.keys(tempDocs).filter(key => key.includes('ID Card / Passport'));\n    idDocs.forEach(key => Object.assign(orderedData, tempDocs[key]));\n\n    const limosaDocs = Object.keys(tempDocs).filter(key => key.includes('Limosa'));\n    limosaDocs.forEach(key => Object.assign(orderedData, tempDocs[key]));\n    \n    const vcaSccDocs = Object.keys(tempDocs).filter(key => key.includes('VCA / SCC'));\n    vcaSccDocs.forEach(key => Object.assign(orderedData, tempDocs[key]));\n    \n    const a1Docs = Object.keys(tempDocs).filter(key => key.includes('A1'));\n    a1Docs.forEach(key => Object.assign(orderedData, tempDocs[key]));\n\n    Object.keys(tempDocs).forEach(key => {\n        if (!Object.keys(orderedData).includes(key) && !key.includes('ID Card') && !key.includes('Limosa') && !key.includes('VCA') && !key.includes('A1')) {\n             Object.assign(orderedData, tempDocs[key]);\n        }\n    });\n\n    const generalData = {};\n    generalData['Decision'] = data.decision || 'UNKNOWN';\n    generalData['Overall_Status'] = data.overall_status || validation.overall_status || 'UNKNOWN';\n    generalData['Validation_Date'] = validation.validation_date || new Date().toLocaleDateString('en-US');\n    generalData['Total_Documents_Processed'] = data.total_documents_processed || validation.documents_processed || allDocuments.length;\n    \n    const mandatoryDocs = report.mandatory_documents_check || {};\n    const documentStatusFields = [\n        'social_security_document_present', 'identity_document_present', 'work_notification_present',\n        'safety_certificate_present', 'professional_certificate_present', 'training_certificate_present',\n        'medical_certificate_present', 'all_mandatory_present'\n    ];\n    for (const field of documentStatusFields) {\n        if (mandatoryDocs[field] !== undefined) {\n            let displayName = field.replace(/_present$/, '').replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            if (displayName === 'Identity Document') {\n                displayName = 'ID Card / Passport';\n            } else if (displayName === 'Social Security Document') {\n                displayName = 'A1';\n            } else if (displayName === 'Work Notification') {\n                displayName = 'Limosa';\n            } else if (displayName === 'Safety Certificate') {\n                displayName = 'VCA/SCC';\n            }\n            generalData[`${displayName}_Status`] = mandatoryDocs[field];\n        }\n    }\n    \n    const personalComparison = report.personal_data_comparison || {};\n    const consistencyFields = ['name', 'birth_date', 'personal_identifier', 'nationality'];\n    for (const field of consistencyFields) {\n        if (personalComparison[field]?.status) {\n            const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            generalData[`${displayName}_Consistency`] = personalComparison[field].status;\n            if (personalComparison[field].issues) {\n                generalData[`${displayName}_Issues`] = personalComparison[field].issues;\n            }\n        }\n    }\n    \n    const crossConsistency = report.cross_document_consistency || {};\n    for (const [field, value] of Object.entries(crossConsistency)) {\n        if (value !== undefined) {\n            const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            generalData[`Cross_${displayName}`] = value;\n        }\n    }\n    \n    const docValidity = report.document_validity_check || {};\n    for (const [field, value] of Object.entries(docValidity)) {\n        if (value !== undefined && value !== 'N/A') {\n            const displayName = field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            generalData[`Validity_${displayName}`] = value;\n        }\n    }\n    \n    const flags = report.flags_and_warnings || data.full_validation_report?.flags_and_warnings || [];\n    const flagsAndWarnings = {};\n    flagsAndWarnings['Total_Issues'] = flags.length;\n    flagsAndWarnings['Critical_Issues_Count'] = flags.filter(f => f.type === 'CRITICAL').length;\n    flagsAndWarnings['Error_Count'] = flags.filter(f => f.type === 'ERROR').length;\n    flagsAndWarnings['Warning_Count'] = flags.filter(f => f.type === 'WARNING').length;\n    flags.slice(0, 5).forEach((flag, index) => {\n        flagsAndWarnings[`Issue_${index + 1}_Type`] = flag.type;\n        flagsAndWarnings[`Issue_${index + 1}_Field`] = flag.field || 'N/A';\n        flagsAndWarnings[`Issue_${index + 1}_Message`] = flag.message;\n        if (flag.weighted_severity) {\n            flagsAndWarnings[`Issue_${index + 1}_Severity`] = flag.weighted_severity;\n        }\n    });\n    \n    const recommendations = report.recommendations || data.full_validation_report?.recommendations || [];\n    const recommendationsData = {};\n    recommendationsData['Total_Recommendations'] = recommendations.length;\n    recommendations.slice(0, 3).forEach((rec, index) => {\n        recommendationsData[`Recommendation_${index + 1}`] = rec;\n    });\n    \n    const metadata = {};\n    if (validation.destination_country) {\n        metadata['Destination_Country'] = validation.destination_country;\n    }\n\n    return {\n        ...generalData,\n        ...orderedData,\n        ...flagsAndWarnings,\n        ...recommendationsData,\n        ...metadata\n    };\n}\n\n/**\n * Escapet speciale karakters in een string om het veilig te gebruiken in XML.\n */\nfunction escapeXml(unsafe) {\n    if (unsafe === null || unsafe === undefined) return '';\n    return String(unsafe)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n\n// === HOOFDLOGICA ===\n\nconst reportData = extractAllData(jsonData);\n\nconst workerName = reportData['ID Card / Passport_Surname'] || reportData.Worker_Name || 'Unknown_Worker';\nconst cleanWorkerName = workerName.replace(/[^a-zA-Z0-9\\s-]/g, '').replace(/\\s+/g, '_');\nconst dateStr = new Date().toISOString().split('T')[0];\nconst fileName = `Complete_Validation_Report_${cleanWorkerName}_${dateStr}.xls`;\n\nconst excelXML = `<?xml version=\"1.0\"?>\n<?mso-application progid=\"Excel.Sheet\"?>\n<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\n xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\">\n <DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\n  <Title>Complete Document Validation Report</Title>\n  <Subject>Worker: ${escapeXml(workerName)}</Subject>\n  <Created>${new Date().toISOString()}</Created>\n </DocumentProperties>\n <Styles>\n  <Style ss:ID=\"Header\">\n   <Font ss:Bold=\"1\" ss:Size=\"11\"/>\n   <Interior ss:Color=\"#D9E1F2\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Pass\">\n   <Interior ss:Color=\"#C6EFCE\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Fail\">\n   <Interior ss:Color=\"#FFC7CE\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Warn\">\n   <Interior ss:Color=\"#FFEB9C\" ss:Pattern=\"Solid\"/>\n  </Style>\n  <Style ss:ID=\"Critical\">\n   <Interior ss:Color=\"#FF6B6B\" ss:Pattern=\"Solid\"/>\n   <Font ss:Bold=\"1\"/>\n  </Style>\n  <Style ss:ID=\"Default\"/>\n </Styles>\n <Worksheet ss:Name=\"Complete Validation Report\">\n  <Table>\n    <Column ss:StyleID=\"Header\" ss:AutoFitWidth=\"1\" ss:Width=\"200\"/>\n    <Column ss:AutoFitWidth=\"1\" ss:Width=\"300\"/>\n${Object.entries(reportData).map(([key, value]) => {\n    const valStr = String(value).toUpperCase();\n    let valueStyleID = 'Default';\n    \n    if (valStr.includes('PASS') || valStr.includes('YES') || valStr.includes('MATCH') || valStr === 'TRUE' || valStr.includes('VALID')) {\n        valueStyleID = 'Pass';\n    } else if (valStr.includes('FAIL') || valStr.includes('NO') || valStr.includes('MISMATCH') || valStr === 'FALSE') {\n        valueStyleID = 'Fail';\n    } else if (valStr.includes('CRITICAL')) {\n        valueStyleID = 'Critical';\n    } else if (valStr.includes('WARNING') || valStr.includes('REVIEW') || valStr.includes('UNKNOWN') || valStr.includes('ERROR')) {\n        valueStyleID = 'Warn';\n    }\n    \n    return `    <Row>\n     <Cell ss:StyleID=\"Header\"><Data ss:Type=\"String\">${escapeXml(key.replace(/_/g, ' '))}</Data></Cell>\n     <Cell ss:StyleID=\"${valueStyleID}\"><Data ss:Type=\"String\">${escapeXml(String(value ?? ''))}</Data></Cell>\n    </Row>`;\n}).join('\\n')}\n  </Table>\n </Worksheet>\n</Workbook>`;\n\nreturn {\n    json: {\n        ...jsonData,\n        excelGenerated: true,\n        excelFilename: fileName,\n        totalDataPoints: Object.keys(reportData).length,\n        reportSummary: {\n            decision: reportData.Decision,\n            status: reportData.Overall_Status,\n            criticalIssues: reportData.Critical_Issues_Count,\n            totalDocuments: reportData.Total_Documents_Processed\n        }\n    },\n    binary: {\n        ...($input.first().binary || {}),\n        file: {\n            data: Buffer.from(excelXML, 'utf8').toString('base64'),\n            mimeType: 'application/vnd.ms-excel',\n            fileName: fileName\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -384,
        928
      ],
      "id": "1859f32e-5786-4e64-8975-f9f0f1334c7b",
      "name": "create xlsx1"
    },
    {
      "parameters": {
        "jsCode": "// JSON data ophalen uit de vorige node\nconst jsonData = $input.first().json;\n\n// ===== CONSTANTEN =====\nconst DOCUMENT_TYPE_MAPPINGS = {\n    'Identity Document': 'ID Card / Passport',\n    'Passport': 'ID Card / Passport', \n    'Social Security Document': 'A1',\n    'Social Security': 'A1',\n    'Socialsecurity': 'A1',\n    'Work Notification': 'Limosa',\n    'Safety Certificate': 'VCA / SCC'\n};\n\nconst DOCUMENT_ORDER = ['ID Card / Passport', 'Limosa', 'VCA / SCC', 'A1'];\n\nconst PRIORITY_FIELDS = [\n    'document_type', 'certificate_type', 'document_number', 'certificate_number',\n    'given_names', 'surname', 'worker_name', 'holder_name', 'employee_name',\n    'birth_date', 'nationality', 'gender', 'personal_identifier',\n    'work_period_start', 'work_period_end', 'expiry_date', 'issue_date',\n    'employer_name', 'sending_company', 'work_location', 'sector',\n    'issuing_country', 'issuing_authority', 'notification_country', \n    'firm_issuing', 'issue_place', 'basis_of_vol'\n];\n\nconst DOCUMENT_STATUS_FIELDS = [\n    'social_security_document_present', 'identity_document_present', \n    'work_notification_present', 'safety_certificate_present', \n    'professional_certificate_present', 'training_certificate_present',\n    'medical_certificate_present', 'all_mandatory_present'\n];\n\nconst CONSISTENCY_FIELDS = ['name', 'birth_date', 'personal_identifier', 'nationality'];\n\nconst EXCEL_STYLES = {\n    Header: { backgroundColor: '#D9E1F2', bold: true },\n    Pass: { backgroundColor: '#C6EFCE' },\n    Fail: { backgroundColor: '#FFC7CE' },\n    Warn: { backgroundColor: '#FFEB9C' },\n    Critical: { backgroundColor: '#FF6B6B', bold: true },\n    Default: {}\n};\n\n// ===== UTILITY FUNCTIES =====\n\n/**\n * Helper functie om veilig waarden uit nested objecten te halen\n * @param {Object} obj - Het object om te doorzoeken\n * @param {string} path - Het pad naar de gewenste waarde (bijv. 'a.b.c')\n * @param {*} defaultValue - De standaardwaarde als de waarde niet gevonden wordt\n * @returns {*} De gevonden waarde of de standaardwaarde\n */\nfunction getValue(obj, path, defaultValue = 'N/A') {\n    try {\n        if (!obj || typeof obj !== 'object') return defaultValue;\n        \n        const value = path.split('.').reduce((acc, key) => {\n            return (acc && typeof acc === 'object' && key in acc) ? acc[key] : undefined;\n        }, obj);\n        \n        return value !== undefined && value !== null && value !== '' ? value : defaultValue;\n    } catch (error) {\n        console.warn(`Error accessing path ${path}:`, error.message);\n        return defaultValue;\n    }\n}\n\n/**\n * Zoekt door alle documenten naar een specifiek veld\n * @param {Array} documents - Array van documenten om te doorzoeken\n * @param {Array} fieldNames - Array van veldnamen om naar te zoeken\n * @returns {*} De eerste gevonden waarde of 'N/A'\n */\nfunction findInAllDocuments(documents, fieldNames) {\n    if (!Array.isArray(documents) || !Array.isArray(fieldNames)) return 'N/A';\n    \n    for (const fieldName of fieldNames) {\n        for (const doc of documents) {\n            const value = doc?.[fieldName];\n            if (value && value !== 'N/A' && value !== '') {\n                return value;\n            }\n        }\n    }\n    return 'N/A';\n}\n\n/**\n * Escapet speciale karakters in een string om het veilig te gebruiken in XML\n * @param {*} unsafe - De waarde om te escapen\n * @returns {string} De geëscapete string\n */\nfunction escapeXml(unsafe) {\n    if (unsafe === null || unsafe === undefined) return '';\n    \n    return String(unsafe)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n\n/**\n * Normaliseert documenttype namen volgens de mapping\n * @param {string} categoryName - De originele categorienaam\n * @returns {string} De genormaliseerde naam\n */\nfunction normalizeDocumentType(categoryName) {\n    // Exacte matches eerst proberen\n    if (DOCUMENT_TYPE_MAPPINGS[categoryName]) {\n        return DOCUMENT_TYPE_MAPPINGS[categoryName];\n    }\n    \n    // Daarna partial matches\n    for (const [key, value] of Object.entries(DOCUMENT_TYPE_MAPPINGS)) {\n        if (categoryName.includes(key)) {\n            return value;\n        }\n    }\n    \n    // Speciale handling voor Social Security varianten\n    if (categoryName.toLowerCase().includes('social security') || \n        categoryName.toLowerCase().includes('socialsecurity')) {\n        return 'A1';\n    }\n    \n    return categoryName;\n}\n\n/**\n * Bepaalt de Excel style op basis van de waarde\n * @param {string} value - De waarde om te controleren\n * @returns {string} De style ID\n */\nfunction getExcelStyleForValue(value) {\n    const valStr = String(value).toUpperCase();\n    \n    if (valStr.includes('CRITICAL')) return 'Critical';\n    if (valStr.includes('PASS') || valStr.includes('YES') || valStr.includes('MATCH') || \n        valStr === 'TRUE' || valStr.includes('VALID')) return 'Pass';\n    if (valStr.includes('FAIL') || valStr.includes('NO') || valStr.includes('MISMATCH') || \n        valStr === 'FALSE') return 'Fail';\n    if (valStr.includes('WARNING') || valStr.includes('REVIEW') || \n        valStr.includes('UNKNOWN') || valStr.includes('ERROR')) return 'Warn';\n    \n    return 'Default';\n}\n\n/**\n * Formatteert een veldnaam voor weergave\n * @param {string} fieldName - De originele veldnaam\n * @returns {string} De geformatteerde naam\n */\nfunction formatDisplayName(fieldName) {\n    return fieldName\n        .replace(/_/g, ' ')\n        .replace(/\\b\\w/g, l => l.toUpperCase());\n}\n\n// ===== DOCUMENT PROCESSING FUNCTIES =====\n\n/**\n * Verwerkt een enkel document en extraheert alle relevante velden\n * @param {Object} doc - Het document object\n * @param {string} prefix - De prefix voor de veldnamen\n * @returns {Object} Object met alle geëxtraheerde velden\n */\nfunction processDocument(doc, prefix) {\n    if (!doc || typeof doc !== 'object' || Object.keys(doc).length === 0) {\n        return {};\n    }\n\n    const processedDoc = {};\n\n    // Verwerk priority fields eerst\n    for (const field of PRIORITY_FIELDS) {\n        const value = doc[field];\n        if (value !== undefined && value !== null && value !== '') {\n            const displayName = formatDisplayName(field);\n            processedDoc[`${prefix}_${displayName}`] = value;\n        }\n    }\n\n    // Verwerk overige velden\n    for (const [field, value] of Object.entries(doc)) {\n        if (PRIORITY_FIELDS.includes(field) || field === 'additional_fields' || \n            value === undefined || value === null || value === '') {\n            continue;\n        }\n\n        let displayValue = value;\n        if (Array.isArray(displayValue)) {\n            displayValue = displayValue.join(', ');\n        } else if (typeof displayValue === 'object') {\n            continue;\n        }\n\n        const displayName = formatDisplayName(field);\n        processedDoc[`${prefix}_${displayName}`] = displayValue;\n    }\n\n    // Verwerk boolean velden\n    ['stamp_present', 'signature_present'].forEach(field => {\n        if (doc[field] !== undefined) {\n            const displayName = formatDisplayName(field);\n            processedDoc[`${prefix}_${displayName}`] = doc[field] ? 'YES' : 'NO';\n        }\n    });\n\n    // Verwerk additional_fields\n    if (doc.additional_fields && typeof doc.additional_fields === 'object') {\n        for (const [field, value] of Object.entries(doc.additional_fields)) {\n            if (field.includes('_confidence') || value === undefined || \n                value === null || value === '') continue;\n\n            let displayValue = value;\n            if (typeof value === 'boolean') {\n                displayValue = value ? 'YES' : 'NO';\n            }\n\n            const displayName = formatDisplayName(field);\n            processedDoc[`${prefix}_${displayName}`] = displayValue;\n        }\n    }\n\n    return processedDoc;\n}\n\n/**\n * Verwerkt alle documenten en ordent ze volgens prioriteit\n * @param {Object} originalDocs - Het originalDocs object uit de data\n * @returns {Object} Geordende document data\n */\nfunction processAllDocuments(originalDocs) {\n    if (!originalDocs || typeof originalDocs !== 'object') {\n        return {};\n    }\n\n    const tempDocs = {};\n\n    // Verwerk alle document categorieën\n    for (const [category, docData] of Object.entries(originalDocs)) {\n        if (!docData) continue;\n\n        const documents = Array.isArray(docData) ? docData : [docData];\n        \n        documents.forEach((doc, index) => {\n            if (!doc || Object.keys(doc).length === 0) return;\n\n            let categoryName = category\n                .replace(/_data$/, '')\n                .replace(/_/g, ' ')\n                .replace(/\\b\\w/g, l => l.toUpperCase());\n\n            categoryName = normalizeDocumentType(categoryName);\n            \n            const prefix = documents.length > 1 ? `${categoryName}_${index + 1}` : categoryName;\n            tempDocs[prefix] = processDocument(doc, prefix);\n        });\n    }\n\n    // Orden documenten volgens prioriteit\n    const orderedData = {};\n    \n    // Voeg documenten toe in specifieke volgorde\n    for (const docType of DOCUMENT_ORDER) {\n        const matchingKeys = Object.keys(tempDocs).filter(key => key.includes(docType));\n        matchingKeys.forEach(key => {\n            Object.assign(orderedData, tempDocs[key]);\n        });\n    }\n\n    // Voeg overige documenten toe\n    Object.keys(tempDocs).forEach(key => {\n        if (!DOCUMENT_ORDER.some(docType => key.includes(docType))) {\n            Object.assign(orderedData, tempDocs[key]);\n        }\n    });\n\n    return orderedData;\n}\n\n/**\n * Extraheert algemene validatie data\n * @param {Object} data - De volledige data\n * @param {Object} report - Het report object\n * @param {Object} validation - Het validation summary object\n * @param {Array} allDocuments - Array van alle documenten\n * @returns {Object} Algemene validatie data\n */\nfunction extractGeneralData(data, report, validation, allDocuments) {\n    const generalData = {};\n    \n    // Basis informatie\n    generalData['Decision'] = data.decision || 'UNKNOWN';\n    generalData['Overall_Status'] = data.overall_status || validation.overall_status || 'UNKNOWN';\n    generalData['Validation_Date'] = validation.validation_date || new Date().toLocaleDateString('en-US');\n    generalData['Total_Documents_Processed'] = data.total_documents_processed || \n                                               validation.documents_processed || \n                                               allDocuments.length;\n\n    // Mandatory documents check\n    const mandatoryDocs = report.mandatory_documents_check || {};\n    for (const field of DOCUMENT_STATUS_FIELDS) {\n        if (mandatoryDocs[field] !== undefined) {\n            let displayName = field.replace(/_present$/, '').replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            \n            // Normaliseer de display naam\n            displayName = normalizeDocumentType(displayName);\n            \n            if (displayName === 'VCA / SCC') {\n                displayName = 'VCA/SCC';\n            }\n            \n            generalData[`${displayName}_Status`] = mandatoryDocs[field];\n        }\n    }\n\n    // Personal data comparison\n    const personalComparison = report.personal_data_comparison || {};\n    for (const field of CONSISTENCY_FIELDS) {\n        const fieldData = personalComparison[field];\n        if (fieldData?.status) {\n            const displayName = formatDisplayName(field);\n            generalData[`${displayName}_Consistency`] = fieldData.status;\n            if (fieldData.issues) {\n                generalData[`${displayName}_Issues`] = fieldData.issues;\n            }\n        }\n    }\n\n    // Cross document consistency\n    const crossConsistency = report.cross_document_consistency || {};\n    for (const [field, value] of Object.entries(crossConsistency)) {\n        if (value !== undefined) {\n            const displayName = formatDisplayName(field);\n            generalData[`Cross_${displayName}`] = value;\n        }\n    }\n\n    // Document validity check\n    const docValidity = report.document_validity_check || {};\n    for (const [field, value] of Object.entries(docValidity)) {\n        if (value !== undefined && value !== 'N/A') {\n            const displayName = formatDisplayName(field);\n            generalData[`Validity_${displayName}`] = value;\n        }\n    }\n\n    return generalData;\n}\n\n/**\n * Extraheert flags en warnings data\n * @param {Object} report - Het report object\n * @param {Object} data - De volledige data\n * @returns {Object} Flags en warnings data\n */\nfunction extractFlagsAndWarnings(report, data) {\n    const flags = report.flags_and_warnings || data.full_validation_report?.flags_and_warnings || [];\n    const flagsData = {};\n    \n    // Totalen\n    flagsData['Total_Issues'] = flags.length;\n    flagsData['Critical_Issues_Count'] = flags.filter(f => f.type === 'CRITICAL').length;\n    flagsData['Error_Count'] = flags.filter(f => f.type === 'ERROR').length;\n    flagsData['Warning_Count'] = flags.filter(f => f.type === 'WARNING').length;\n    \n    // Details van eerste 5 issues\n    flags.slice(0, 5).forEach((flag, index) => {\n        const num = index + 1;\n        flagsData[`Issue_${num}_Type`] = flag.type;\n        flagsData[`Issue_${num}_Field`] = flag.field || 'N/A';\n        flagsData[`Issue_${num}_Message`] = flag.message;\n        \n        if (flag.weighted_severity) {\n            flagsData[`Issue_${num}_Severity`] = flag.weighted_severity;\n        }\n    });\n    \n    return flagsData;\n}\n\n/**\n * Extraheert recommendations data\n * @param {Object} report - Het report object\n * @param {Object} data - De volledige data\n * @returns {Object} Recommendations data\n */\nfunction extractRecommendations(report, data) {\n    const recommendations = report.recommendations || data.full_validation_report?.recommendations || [];\n    const recommendationsData = {};\n    \n    recommendationsData['Total_Recommendations'] = recommendations.length;\n    \n    recommendations.slice(0, 3).forEach((rec, index) => {\n        recommendationsData[`Recommendation_${index + 1}`] = rec;\n    });\n    \n    return recommendationsData;\n}\n\n/**\n * Extraheert metadata\n * @param {Object} validation - Het validation summary object\n * @returns {Object} Metadata\n */\nfunction extractMetadata(validation) {\n    const metadata = {};\n    \n    if (validation.destination_country) {\n        metadata['Destination_Country'] = validation.destination_country;\n    }\n    \n    return metadata;\n}\n\n/**\n * Hoofdfunctie om alle data uit het complexe JSON-object te extraheren\n * @param {Object} data - Het volledige data object\n * @returns {Object} Alle geëxtraheerde data in geordende vorm\n */\nfunction extractAllData(data) {\n    try {\n        // Veilig data structuren ophalen\n        const report = getValue(data, 'full_validation_report.individual_reports.0') || \n                      getValue(data, 'full_validation_report') || \n                      data;\n        \n        const validation = getValue(data, 'full_validation_report.validation_summary') || \n                          getValue(report, 'validation_summary') || \n                          {};\n        \n        const originalDocs = getValue(report, 'original_document_details') || {};\n\n        // Maak een platte lijst van alle documenten\n        const allDocuments = [];\n        for (const [category, docData] of Object.entries(originalDocs)) {\n            if (docData) {\n                const documents = Array.isArray(docData) ? docData : [docData];\n                documents.forEach(doc => {\n                    if (doc && typeof doc === 'object') {\n                        allDocuments.push({ category, ...doc });\n                    }\n                });\n            }\n        }\n\n        // Extraheer verschillende data secties\n        const generalData = extractGeneralData(data, report, validation, allDocuments);\n        const documentData = processAllDocuments(originalDocs);\n        const flagsData = extractFlagsAndWarnings(report, data);\n        const recommendationsData = extractRecommendations(report, data);\n        const metadata = extractMetadata(validation);\n\n        // Combineer alle data\n        return {\n            ...generalData,\n            ...documentData,\n            ...flagsData,\n            ...recommendationsData,\n            ...metadata\n        };\n        \n    } catch (error) {\n        console.error('Error extracting data:', error);\n        return {\n            'Error': 'Data extraction failed',\n            'Error_Message': error.message,\n            'Decision': 'ERROR',\n            'Overall_Status': 'PROCESSING_ERROR'\n        };\n    }\n}\n\n/**\n * Genereert Excel XML content\n * @param {Object} reportData - De report data\n * @param {string} workerName - De naam van de werker\n * @returns {string} Excel XML content\n */\nfunction generateExcelXML(reportData, workerName) {\n    const styles = Object.entries(EXCEL_STYLES).map(([id, style]) => {\n        const fontProps = style.bold ? ' ss:Bold=\"1\"' : '';\n        const interiorProps = style.backgroundColor ? \n            ` ss:Color=\"${style.backgroundColor}\" ss:Pattern=\"Solid\"` : '';\n        \n        return `  <Style ss:ID=\"${id}\">\n   <Font ss:Size=\"11\"${fontProps}/>\n   ${interiorProps ? `<Interior${interiorProps}/>` : ''}\n  </Style>`;\n    }).join('\\n');\n\n    const rows = Object.entries(reportData).map(([key, value]) => {\n        const styleID = getExcelStyleForValue(value);\n        const displayKey = key.replace(/_/g, ' ');\n        \n        return `    <Row>\n     <Cell ss:StyleID=\"Header\"><Data ss:Type=\"String\">${escapeXml(displayKey)}</Data></Cell>\n     <Cell ss:StyleID=\"${styleID}\"><Data ss:Type=\"String\">${escapeXml(String(value ?? ''))}</Data></Cell>\n    </Row>`;\n    }).join('\\n');\n\n    return `<?xml version=\"1.0\"?>\n<?mso-application progid=\"Excel.Sheet\"?>\n<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\n xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\">\n <DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\n  <Title>Complete Document Validation Report</Title>\n  <Subject>Worker: ${escapeXml(workerName)}</Subject>\n  <Created>${new Date().toISOString()}</Created>\n </DocumentProperties>\n <Styles>\n${styles}\n </Styles>\n <Worksheet ss:Name=\"Complete Validation Report\">\n  <Table>\n    <Column ss:StyleID=\"Header\" ss:AutoFitWidth=\"1\" ss:Width=\"200\"/>\n    <Column ss:AutoFitWidth=\"1\" ss:Width=\"300\"/>\n${rows}\n  </Table>\n </Worksheet>\n</Workbook>`;\n}\n\n// ===== HOOFDLOGICA =====\n\ntry {\n    // 1. Valideer input data\n    if (!jsonData) {\n        throw new Error('Missing JSON data');\n    }\n    \n    // Handle array input - neem het eerste element als het een array is\n    let processData = jsonData;\n    if (Array.isArray(jsonData)) {\n        if (jsonData.length === 0) {\n            throw new Error('Empty JSON array provided');\n        }\n        processData = jsonData[0];\n        console.log(`📋 Input is een array met ${jsonData.length} element(en), gebruik het eerste element`);\n    }\n    \n    if (!processData || typeof processData !== 'object') {\n        throw new Error('Invalid JSON data structure');\n    }\n\n    // 2. Extraheer alle data\n    const reportData = extractAllData(processData);\n\n    // 3. Genereer bestandsnaam\n    const workerName = findInAllDocuments([reportData], ['Worker_Name', 'worker_name', 'holder_name', 'employee_name']) || 'Unknown_Worker';\n    const cleanWorkerName = workerName.replace(/[^a-zA-Z0-9\\s-]/g, '').replace(/\\s+/g, '_');\n    const dateStr = new Date().toISOString().split('T')[0];\n    const fileName = `Complete_Validation_Report_${cleanWorkerName}_${dateStr}.xls`;\n\n    // 4. Genereer Excel XML\n    const excelXML = generateExcelXML(reportData, workerName);\n\n    // 5. Log resultaten\n    console.log(`✅ Excel-bestand succesvol gegenereerd voor: ${workerName}`);\n    console.log(`📊 Aantal datapunten geëxtraheerd: ${Object.keys(reportData).length}`);\n    console.log(`📁 Bestandsnaam: ${fileName}`);\n    console.log(`🎯 Beslissing: ${reportData.Decision}`);\n    console.log(`📈 Status: ${reportData.Overall_Status}`);\n\n    // 6. Return de resultaten\n    return {\n        json: {\n            ...jsonData,\n            excelGenerated: true,\n            excelFilename: fileName,\n            totalDataPoints: Object.keys(reportData).length,\n            reportSummary: {\n                decision: reportData.Decision,\n                status: reportData.Overall_Status,\n                criticalIssues: reportData.Critical_Issues_Count || 0,\n                totalDocuments: reportData.Total_Documents_Processed || 0,\n                processingTimestamp: new Date().toISOString()\n            }\n        },\n        binary: {\n            ...($input.first().binary || {}),\n            file: {\n                data: Buffer.from(excelXML, 'utf8').toString('base64'),\n                mimeType: 'application/vnd.ms-excel',\n                fileName: fileName\n            }\n        }\n    };\n\n} catch (error) {\n    console.error('❌ Kritieke fout bij Excel generatie:', error);\n    \n    // Return error informatie maar probeer toch door te gaan\n    return {\n        json: {\n            ...jsonData,\n            excelGenerated: false,\n            error: error.message,\n            errorTimestamp: new Date().toISOString()\n        },\n        binary: $input.first().binary || {}\n    };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        304,
        400
      ],
      "id": "f41f2f69-d739-4a3d-92fc-349bb745e664",
      "name": "excel 3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1056,
        48
      ],
      "id": "e7f07a47-c675-47fb-89f7-60327c01c1e4",
      "name": "Merge1"
    },
    {
      "parameters": {
        "html": "<!DOCTYPE html>\n<html lang=\"nl\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document Validation Report</title>\n    <script src=\"https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js\"></script>\n    <style>\n        body { font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f7f8fa; line-height: 1.6; color: #333; }\n        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }\n        .header { text-align: center; border-bottom: 2px solid #e0e0e0; padding-bottom: 20px; margin-bottom: 30px; }\n        .header h1 { color: #1a73e8; margin: 0; font-size: 28px; font-weight: 600; }\n        .status-box { padding: 8px 16px; border-radius: 99px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; border: 1px solid; }\n        .status-pass { background: #e6f4ea; color: #1e8e3e; border-color: #a8d5b5; }\n        .status-fail { background: #fce8e6; color: #d93025; border-color: #f4b4ab; }\n        .status-warning { background: #feefc3; color: #f29900; border-color: #fbd66d; }\n        .status-unknown { background: #e8eaed; color: #3c4043; border-color: #d1d3d6; }\n        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px; margin-bottom: 20px; }\n        .info-card { background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 5px solid #1a73e8; }\n        .info-card h4 { margin: 0 0 12px 0; color: #3c4043; font-size: 1.1em; border-bottom: 1px solid #ddd; padding-bottom: 8px; }\n        .info-card p { margin: 8px 0; font-size: 0.95em; word-wrap: break-word; }\n        table { width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9em; }\n        th, td { padding: 14px; text-align: left; border-bottom: 1px solid #e0e0e0; }\n        th { background: #f1f3f4; font-weight: 600; color: #3c4043; }\n        .match { color: #1e8e3e; font-weight: 600; }\n        .mismatch { color: #d93025; font-weight: 600; }\n        .partial { color: #f29900; font-weight: 600; }\n        .section { margin-bottom: 40px; }\n        .section h2, .section h3 { color: #1a73e8; border-bottom: 2px solid #f1f3f4; padding-bottom: 10px; margin-bottom: 20px; font-size: 1.5em; font-weight: 600;}\n        .section h3 { font-size: 1.25em; }\n        .highlight { background: #e8f0fe; padding: 20px; border-radius: 8px; border-left: 5px solid #1967d2; margin-top: 30px; }\n        .highlight h3 { color: #1967d2; margin-top: 0; }\n        .warning-item, .note-item, .critical-item { padding: 12px; margin: 8px 0; border-radius: 6px; border-left-width: 5px; border-left-style: solid; }\n        .note-item { background: #f1f3f4; border-left-color: #5f6368; }\n        .critical-item { background: #fce8e6; border-left-color: #d93025; font-weight: bold; }\n    </style>\n</head>\n<body>\n\n    <div id=\"report-container\"></div>\n\n    <script id=\"report-template\" type=\"text/x-handlebars-template\">\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>📋 Document Validation Report</h1>\n            <div class=\"status-box status-{{statusClass validation_summary.overall_status}}\">\n                {{#if (eq validation_summary.overall_status \"PASS\")}}✓{{else}}✗{{/if}}\n                {{validation_summary.overall_status}}\n            </div>\n            <p><strong>Validation Date:</strong> {{formatDate validation_summary.validation_date}}</p>\n        </div>\n        \n        <div class=\"section\">\n            <h2>👤 Employee Information</h2>\n            <div class=\"info-card\">\n                <div class=\"info-grid\">\n                    <div><p><strong>Name:</strong> {{personal_data_comparison.name.identity_doc}}</p></div>\n                    <div><p><strong>Date of Birth:</strong> {{formatDate personal_data_comparison.birth_date.identity_doc}}</p></div>\n                    <div><p><strong>Age:</strong> {{calculateAge personal_data_comparison.birth_date.identity_doc}} years</p></div>\n                    <div><p><strong>Personal ID:</strong> {{personal_data_comparison.personal_identifier.identity_doc}}</p></div>\n                    <div><p><strong>Nationality:</strong> {{personal_data_comparison.nationality.identity_doc}}</p></div>\n                </div>\n            </div>\n        </div>\n\n        <div class=\"section\">\n            <h3>✅ Mandatory Documents</h3>\n            <div class=\"info-card\">\n              {{#each_key_value mandatory_documents_check}}\n                {{#if (ne key \"all_mandatory_present\")}}\n                  <p>\n                    <strong>{{formatTitle key}}:</strong> \n                    {{#if (eq value \"YES\")}}<span class=\"match\">✓ Present</span>{{else}}<span class=\"mismatch\">✗ Missing</span>{{/if}}\n                  </p>\n                {{/if}}\n              {{/each_key_value}}\n            </div>\n        </div>\n\n        <div class=\"section\">\n            <h2>📄 Document Details</h2>\n            <div class=\"info-grid\">\n                {{#each_key_value original_document_details}}\n                    <div class=\"info-card\">\n                        <h4>{{formatTitle key}}</h4>\n                        {{#each_key_value this}}\n                            {{#if (should_show_field key ../key)}}\n                                <p><strong>{{formatTitle key}}:</strong> {{this}}</p>\n                            {{/if}}\n                        {{/each_key_value}}\n                    </div>\n                {{/each_key_value}}\n            </div>\n        </div>\n        \n        <div class=\"section\">\n            <h3>🔄 Data Consistency Check</h3>\n            <table>\n                <thead>\n                    <tr><th>Field</th><th>Value Source</th><th>Status</th></tr>\n                </thead>\n                <tbody>\n                    <tr><td>Name</td><td>{{personal_data_comparison.name.issues}}</td><td><span class=\"{{statusClass personal_data_comparison.name.status}}\">{{personal_data_comparison.name.status}}</span></td></tr>\n                    <tr><td>Date of Birth</td><td>-</td><td><span class=\"{{statusClass personal_data_comparison.birth_date.status}}\">{{personal_data_comparison.birth_date.status}}</span></td></tr>\n                    <tr><td>Personal ID</td><td>{{personal_data_comparison.personal_identifier.issues}}</td><td><span class=\"{{statusClass personal_data_comparison.personal_identifier.status}}\">{{personal_data_comparison.personal_identifier.status}}</span></td></tr>\n                    <tr><td>Nationality</td><td>-</td><td><span class=\"{{statusClass personal_data_comparison.nationality.status}}\">{{personal_data_comparison.nationality.status}}</span></td></tr>\n                </tbody>\n            </table>\n        </div>\n        \n        {{#if flags_and_warnings.length}}\n        <div class=\"section\">\n            <h3>🚨 Notes & Warnings</h3>\n            {{#each flags_and_warnings}}\n            <div class=\"{{statusClass type}}-item\">\n                <strong>{{type}}:</strong> {{message}}\n            </div>\n            {{/each}}\n        </div>\n        {{/if}}\n\n    </div>\n    </script>\n\n    <script>\n        // --- 1. Your JSON Data ---\n        // This is the data that will be used to fill the template.\n        const jsonData = {\n            \"validation_summary\": { \"overall_status\": \"PASS\", \"documents_validated\": [\"A1/Social Security Certificate\", \"National Identity Card/Residence Permit\", \"Work Notification (Limosa)\", \"Safety/Professional Certificate (SVWOH)\", \"Safety/Professional Certificate (SCC)\"], \"validation_date\": \"2025-08-07\", \"worker_nationality\": \"Azerbaijani (AZ)\", \"destination_country\": \"Belgium\" },\n            \"mandatory_documents_check\": { \"social_security_document_present\": \"YES\", \"identity_document_present\": \"YES\", \"work_notification_present\": \"YES\", \"safety_certificate_present\": \"YES\", \"all_mandatory_present\": \"YES\" },\n            \"personal_data_comparison\": { \"name\": { \"social_security_doc\": \"MIRZALI RUSLAN\", \"identity_doc\": \"MIRZALI Ruslan\", \"work_notification\": \"Mirzali Ruslan\", \"safety_certificate\": \"R.U.S.L.A.N. Mirzali (SVWOH), Ruslan Mirzali (SCC)\", \"status\": \"MATCH\", \"issues\": \"Consistent across documents, accounting for case and punctuation variations.\" }, \"birth_date\": { \"social_security_doc\": \"1998-09-09\", \"identity_doc\": \"1998-09-09\", \"safety_certificate\": \"1998-09-09 (SVWOH), 1998-09-09 (SCC)\", \"status\": \"MATCH\" }, \"personal_identifier\": { \"social_security_doc\": \"39809095486\", \"identity_doc\": \"39809095486\", \"type\": \"Lithuanian Personal Code (A1, ID Card), Belgian Identification Number (Limosa)\", \"status\": \"MATCH\", \"issues\": \"Different types of personal identifiers are used across documents, but are consistent within their respective national contexts (Lithuanian Personal Code for LT documents, Belgian ID for Limosa).\" }, \"nationality\": { \"social_security_doc\": \"AZ\", \"identity_doc\": \"AZE\", \"status\": \"MATCH\" } },\n            \"document_validity_check\": { \"identity_document_expiry\": \"2025-10-30\", \"safety_certificate_expiry\": \"2026-06-03 (SVWOH), 2029-01-11 (SCC)\", \"work_period_end\": \"2025-10-30 (A1), 2025-08-30 (Limosa)\", \"validity_status\": \"VALID\" },\n            \"original_document_details\": { \"social_security_data\": { \"document_type\": \"a1_form\", \"worker_name\": \"MIRZALI RUSLAN\", \"birth_date\": \"1998-09-09\", \"personal_identifier\": \"39809095486\", \"nationality\": \"AZ\", \"work_period_start\": \"2024-01-18\", \"work_period_end\": \"2025-10-30\", \"sending_company\": \"UAB \\\\\\\"GLOBALITA\\\\\\\"\", \"receiving_companies\": [\"BILFINGER INDUSTRIAL SERVICES\", \"KAEFER WANNER\", \"ENERSENSE OFFSHORE\", \"VIP SCAFFOLDING\"], \"director_manager\": \"LIGITA PAUKŠTĖ\", \"profession\": \"Posted Worker (implied)\", \"issuing_country\": \"LT\", \"issue_date\": \"2024-02-01\", \"additional_fields\": { \"stamp_present\": true, \"stamp_confidence\": 0.95, \"signature_present\": true, \"signature_confidence\": 0.85, \"luik_3_2_checked\": false, \"luik_4_1_1_checked\": true, \"certificate_id\": \"VTT_PZ1-6405\", \"valid_for_entire_activity_duration\": true, \"temporary_determination\": false, \"employer_code\": \"300870029\", \"employer_registration_address\": \"TAIKOS PR. 62, KLAIPĖDOS MIESTO SAV., KLAIP, 91182, LT\", \"issuing_authority_name\": \"VALSTYBINIO SOCIALINIO DRAUDIMO FONDO VALDYBOS VILNIAUS SKYRIUS\", \"issuing_authority_address\": \"LAISVĖS 28, VILNIUS, LT-04340, LT\", \"issuing_authority_code\": \"191683350\", \"issuing_authority_phone\": \"(+370) 5 250 0883\", \"issuing_authority_email\": \"UZSIENIS@SODRA.LT\" } }, \"identity_document_data\": { \"document_type\": \"id_card\", \"surname\": \"MIRZALI\", \"given_names\": \"Ruslan\", \"birth_date\": \"1998-09-09\", \"personal_identifier\": \"39809095486\", \"nationality\": \"AZE\", \"document_number\": \"760303653\", \"expiry_date\": \"2025-10-30\", \"gender\": \"VYR.\", \"issuing_country\": \"LTU\", \"issuing_authority\": \"MD (227)\", \"issue_date\": \"2023-10-30\", \"additional_fields\": { \"stamp_present\": false, \"stamp_confidence\": 0, \"signature_present\": false, \"signature_confidence\": 0, \"document_subtype\": \"LEIDIMAS LAIKINAI GYVENTI (Residence Permit)\", \"place_of_birth\": \"AZERBAIDŽANAS\" } }, \"work_notification_data\": { \"document_type\": \"limosa\", \"employee_name\": \"Mirzali Ruslan\", \"work_period_start\": \"2025-06-02\", \"work_period_end\": \"2025-08-30\", \"employer_name\": \"UAB -GLOBALITA-\", \"employer_address\": \"TAIKOS PR., Number 62, 93225-KLAIPEDOS M., Lithuania\", \"work_location\": \"INEOS Project One, Scheldelaan, Number 475, 2040 - Antwerpen, Belgium\", \"sector\": \"Other sectors\", \"notification_country\": \"Belgium\", \"employee_identification\": \"98.49.09-421.61\", \"notification_sent_on\": \"2025-06-02 12:24\", \"additional_fields\": { \"stamp_present\": false, \"stamp_confidence\": 0, \"signature_present\": false, \"signature_confidence\": 0, \"declaration_number\": \"24912 0241 0470 3096\", \"employer_vat_number\": \"LT10 0005 0203 18\", \"temporary_work\": \"No\", \"belgian_client_cbe_number\": \"404.000.446\", \"belgian_client_name\": \"Altrad Services\", \"belgian_client_address\": \"Aven Ackers(VER), Number 10, 9130 - Verrebroek\" } }, \"safety_certificate_data\": { \"document_type\": \"svwoh\", \"holder_name\": \"R.U.S.L.A.N. Mirzali\", \"birth_date\": \"1998-09-09\", \"certificate_number\": \"SVWOH-AHM 15674\", \"certificate_type\": \"Aspirant Hulp Monteur Scaffolding Apprentice\", \"expiry_date\": \"2026-06-03\", \"issue_place\": \"Waddinxveen\", \"issuing_country\": \"NLD\", \"exam_date\": \"2025-06-03\", \"additional_fields\": { \"stamp_present\": false, \"stamp_confidence\": 0, \"signature_present\": true, \"signature_confidence\": 0.9, \"issuing_organization\": \"Stichting Veilig Werken Op Hoogte (SVWOH)\", \"signed_by_certificate_holder\": true } }, \"safety_certificate_data_2\": { \"document_type\": \"scc\", \"holder_name\": \"Ruslan Mirzali\", \"birth_date\": \"1998-09-09\", \"certificate_number\": \"V1162-10149\", \"certificate_type\": \"SGU-PRÜFUNG VON OPERATIV TÄTIGEN MITARBEITERN\", \"expiry_date\": \"2029-01-11\", \"issue_place\": \"Kassel\", \"issuing_country\": \"DEU\", \"exam_date\": \"2024-01-11\", \"additional_fields\": { \"stamp_present\": true, \"stamp_confidence\": 0.9, \"signature_present\": true, \"signature_confidence\": 0.9, \"exam_location\": \"Spijkenisse\", \"issuing_organization\": \"CertEuropA GmbH\" } } },\n            \"cross_document_consistency\": { \"work_periods_align\": \"YES\", \"employer_consistency\": \"YES\", \"location_consistency\": \"PARTIAL\", \"eu_regulation_compliance\": \"YES\" },\n            \"flags_and_warnings\": [{ \"type\": \"NOTE\", \"field\": \"worker_nationality\", \"message\": \"Worker is an Azerbaijani national (non-EU). However, they hold a valid Lithuanian Residence Permit, which, combined with the A1 certificate and Limosa declaration, indicates proper authorization for posting from an EU member state (Lithuania) to another EU member state (Belgium) under EU regulations.\", \"country_specific\": \"Lithuania, Belgium\" }, { \"type\": \"NOTE\", \"field\": \"work_location_consistency\", \"message\": \"The A1 certificate lists multiple potential receiving company locations in Belgium (Zeebrugge), while the Limosa declaration specifies a different work location in Belgium (Antwerpen). This is acceptable as the A1 covers a broader scope of potential work sites.\", \"country_specific\": \"Belgium\" }],\n            \"recommendations\": []\n        };\n\n        // --- 2. Handlebars Helper Functions ---\n        // These are small functions to format data or add logic to the template.\n\n        // Converts YYYY-MM-DD to DD-MM-YYYY\n        Handlebars.registerHelper('formatDate', function(dateStr) {\n            if (!dateStr || typeof dateStr !== 'string') return 'N/A';\n            const [year, month, day] = dateStr.split('-');\n            return `${day}-${month}-${year}`;\n        });\n\n        // Calculates age from a birth date string\n        Handlebars.registerHelper('calculateAge', function(birthDate) {\n            if (!birthDate) return 'N/A';\n            const today = new Date();\n            const birth = new Date(birthDate);\n            let age = today.getFullYear() - birth.getFullYear();\n            const m = today.getMonth() - birth.getMonth();\n            if (m < 0 || (m === 0 && today.getDate() < birth.getDate())) {\n                age--;\n            }\n            return age;\n        });\n        \n        // General purpose \"if value A equals value B\"\n        Handlebars.registerHelper('eq', (a, b) => a === b);\n        Handlebars.registerHelper('ne', (a, b) => a !== b);\n\n        // Allows looping over keys and values of an object\n        Handlebars.registerHelper('each_key_value', function(context, options) {\n            let ret = \"\";\n            if(context && typeof context === 'object') {\n                for (const key in context) {\n                    if (Object.prototype.hasOwnProperty.call(context, key)) {\n                        ret += options.fn({ key: key, value: context[key], ...context[key] });\n                    }\n                }\n            }\n            return ret;\n        });\n\n        // Makes field names and titles look nice\n        Handlebars.registerHelper('formatTitle', function(key) {\n            if (typeof key !== 'string') return '';\n            const titleMap = {\n                'social_security_data': 'A1 Social Security Certificate',\n                'identity_document_data': 'Identity Document / Residence Permit',\n                'work_notification_data': 'Work Notification (Limosa)',\n                'safety_certificate_data': 'Safety Certificate (SVWOH)',\n                'safety_certificate_data_2': 'Safety Certificate (SCC)',\n                'social_security_document_present': 'A1/Social Security Document',\n                'identity_document_present': 'Identity Document',\n                'work_notification_present': 'Work Notification',\n                'safety_certificate_present': 'Safety Certificate(s)',\n                'document_type': 'Document Type', 'worker_name': 'Worker Name', 'holder_name': 'Holder Name', 'employee_name': 'Employee Name',\n                'birth_date': 'Date of Birth', 'personal_identifier': 'Personal ID', 'document_number': 'Document Number',\n                'expiry_date': 'Expiry Date', 'issue_date': 'Issue Date', 'work_period_start': 'Work Period Start',\n                'work_period_end': 'Work Period End', 'sending_company': 'Sending Company', 'receiving_companies': 'Receiving Companies',\n                'issuing_country': 'Issuing Country', 'additional_fields': 'Additional Info', 'director_manager': 'Director/Manager',\n                'employer_name': 'Employer', 'work_location': 'Work Location'\n            };\n            return titleMap[key] || key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n        });\n\n        // Logic to decide which fields to show in the document details\n        Handlebars.registerHelper('should_show_field', function(field, category) {\n            // Fields to ALWAYS hide (technical details)\n            const fieldsToHide = ['additional_fields', 'stamp_confidence', 'signature_confidence'];\n            if (fieldsToHide.includes(field) || field.startsWith('luik_')) {\n                return false;\n            }\n            // Fields to only show for the A1 form\n            const a1OnlyFields = ['stamp_present', 'signature_present'];\n            if (a1OnlyFields.includes(field) && category !== 'social_security_data') {\n                return false;\n            }\n            return true;\n        });\n        \n        // Returns a CSS class based on a status string\n        Handlebars.registerHelper('statusClass', (status) => {\n          if (!status) return 'unknown';\n          status = status.toLowerCase();\n          if (status === 'pass' || status === 'match' || status === 'yes') return 'pass';\n          if (status === 'fail' || status === 'mismatch' || status === 'no') return 'fail';\n          if (status === 'review' || status === 'warning' || status === 'partial') return 'warning';\n          if (status === 'note') return 'note';\n          return 'unknown';\n        });\n\n        // --- 3. Compile and Render ---\n        // This part runs when the page loads.\n        document.addEventListener('DOMContentLoaded', function() {\n            const source = document.getElementById('report-template').innerHTML;\n            const template = Handlebars.compile(source);\n            const html = template(jsonData);\n            document.getElementById('report-container').innerHTML = html;\n        });\n\n    </script>\n</body>\n</html>\n"
      },
      "type": "n8n-nodes-base.html",
      "typeVersion": 1.2,
      "position": [
        192,
        32
      ],
      "id": "64168410-498d-405f-b9b7-6b52beba0302",
      "name": "HTML"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://pdfmaker.reffey.nl/forms/chromium/convert/html",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "files",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "output.pdf"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        928,
        32
      ],
      "id": "9a040182-afba-457c-8348-7f616aa77f5a",
      "name": "Convert to PDF1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "56ddeb35-240e-44eb-87e5-d2d63bb6b6f3",
              "name": "html",
              "value": "={{ $json.html.base64Encode() }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        464,
        16
      ],
      "id": "5e98f464-5c30-4b3c-9f1e-f96fe844cd7e",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "html",
        "options": {
          "fileName": "index.html",
          "mimeType": "text/html"
        }
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        688,
        16
      ],
      "id": "2c1d7c33-62a5-481a-a75f-091f1e7b323f",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Dit script verwerkt de JSON-output van een AI-validatieagent,\n * combineert de resultaten en voegt extra compliance-checks toe\n * zonder de oorspronkelijke beslissing van de AI te overrulen.\n */\n\n// =================================================================\n// STAP 1: HULPFUNCTIES\n// =================================================================\n\n/**\n * Converteert een datumstring van ISO-formaat (JJJJ-MM-DD) naar Europees formaat (DD/MM/JJJJ).\n * @param {string} dateStr De datumstring om te converteren.\n * @returns {string} De geconverteerde datum of de originele string als het formaat niet overeenkomt.\n */\nfunction convertIsoToEuropean(dateStr) {\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n        const [year, month, day] = dateStr.split(\"-\");\n        return `${day}/${month}/${year}`;\n    }\n    return dateStr;\n}\n\n/**\n * Loopt door een object of array en converteert alle datumstrings.\n * @param {object|array} obj Het object of de array om te converteren.\n * @returns {object|array} De geconverteerde data.\n */\nfunction convertDatesInObject(obj) {\n    if (Array.isArray(obj)) {\n        return obj.map(convertDatesInObject);\n    } else if (typeof obj === 'object' && obj !== null) {\n        const newObj = {};\n        for (const key in obj) {\n            newObj[key] = convertDatesInObject(obj[key]);\n        }\n        return newObj;\n    } else if (typeof obj === 'string') {\n        return convertIsoToEuropean(obj);\n    } else {\n        return obj;\n    }\n}\n\n// =================================================================\n// STAP 2: DATA INLADEN EN VOORBEREIDEN\n// =================================================================\n\nconst validationResults = [];\n// 'items' is de input van de n8n-node.\nitems.forEach(item => {\n    try {\n        const outputText = item.json.output;\n        // Pakt de JSON uit de markdown-codeblokken.\n        const jsonMatch = outputText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n        let jsonData = jsonMatch && jsonMatch[1] ? JSON.parse(jsonMatch[1].trim()) : JSON.parse(outputText.trim());\n        \n        const convertedData = convertDatesInObject(jsonData);\n        validationResults.push(convertedData);\n    } catch (e) {\n        console.log('Error parsing AI output:', e.message);\n    }\n});\n\n// Vangnet voor als er geen geldige JSON is gevonden.\nif (validationResults.length === 0) {\n    return [{\n        json: {\n            decision: \"FAIL\",\n            reason: \"No valid validation results found from AI Agent.\",\n            action: \"reject\",\n            missing_documents: [\"Unable to determine\"],\n            recommendation: \"AI did not produce a valid validation report. Please investigate AI Agent output.\"\n        }\n    }];\n}\n\n// =================================================================\n// STAP 3: COMBINEER RESULTATEN EN VOER EXTRA CHECKS UIT\n// Deze functie is het hart van de logica.\n// =================================================================\n\nfunction combineValidationResults(results) {\n    // Initialiseer alle variabelen.\n    const combinedFlags = [];\n    const combinedRecommendations = []; // GECORRIGEERD: Deze variabele wordt hier aangemaakt.\n    const missingDocuments = [];\n    let overallStatus = \"PASS\";\n    let totalCriticalIssues = 0;\n\n    // Hard-gecodeerde bedrijfsregels voor documenttypes.\n    const documentTypeRules = {\n        'a1_form': { required: true, priority: 'CRITICAL', criticalWeight: 5, requiresStamp: true, requiresSignature: true },\n        'id_card': { required: true, priority: 'CRITICAL', criticalWeight: 5, requiresStamp: false, requiresSignature: false },\n        'limosa': { required: true, priority: 'CRITICAL', criticalWeight: 4, requiresStamp: false, requiresSignature: false },\n        'svwoh': { required: true, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'certificate': { required: true, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'passport': { required: false, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'residence_permit': { required: false, priority: 'HIGH', criticalWeight: 3, requiresStamp: true, requiresSignature: false }\n    };\n\n    const allDocumentTypes = new Set();\n    const documentsByType = {};\n    const stampSignatureCompliance = {\n        missing_stamps: [],\n        missing_signatures: [],\n        low_confidence_items: [],\n        luik_checkbox_issues: []\n    };\n\n    console.log(`Processing ${results.length} EU work document validation reports`);\n\n    results.forEach((report, index) => {\n        // Bepaal de overkoepelende status.\n        const reportStatus = report.validation_summary?.overall_status;\n        if (reportStatus === \"FAIL\") {\n            overallStatus = \"FAIL\";\n        } else if (reportStatus === \"WARNING\" && overallStatus !== \"FAIL\") {\n            overallStatus = \"WARNING\";\n        }\n\n        // Extraheer documenttypes uit het rapport.\n        const reportDocumentTypes = extractAllDocumentTypes(report);\n        reportDocumentTypes.forEach(docType => {\n            allDocumentTypes.add(docType);\n            if (!documentsByType[docType]) {\n                documentsByType[docType] = [];\n            }\n            documentsByType[docType].push({ report, index, docType });\n        });\n        \n        // Analyseer compliance op basis van de hard-gecodeerde regels.\n        analyzeReportCompliance(report, reportDocumentTypes, stampSignatureCompliance, documentTypeRules);\n        \n        // Verzamel vlaggen en aanbevelingen uit de AI-rapporten.\n        if (report.flags_and_warnings) {\n            report.flags_and_warnings.forEach(flag => {\n                const avgWeight = reportDocumentTypes.reduce((sum, type) => sum + (documentTypeRules[type]?.criticalWeight || 1), 0) / reportDocumentTypes.length;\n                combinedFlags.push({ ...flag, weighted_severity: calculateWeightedSeverity(flag.type, avgWeight) });\n            });\n        }\n\n        if (report.recommendations) {\n            const docRecommendations = Array.isArray(report.recommendations) ? report.recommendations : [report.recommendations];\n            docRecommendations.forEach(rec => {\n                combinedRecommendations.push(`[${reportDocumentTypes.join(',').toUpperCase()}] ${rec}`);\n            });\n        }\n    });\n    \n    // Functie om alle documenttypes uit een rapport te halen.\n    function extractAllDocumentTypes(report) {\n        const types = [];\n        if (report.original_document_details) {\n            const details = report.original_document_details;\n            if (details.social_security_data?.document_type) types.push('a1_form');\n            if (details.identity_document_data?.document_type) types.push('id_card');\n            if (details.work_notification_data?.document_type) types.push('limosa');\n            if (details.safety_certificate_data) types.push('certificate');\n        }\n        return types.length > 0 ? types : ['unknown'];\n    }\n    \n    // Functie om de compliance-checks uit te voeren.\n    function analyzeReportCompliance(report, documentTypes, compliance, rules) {\n      if (!report.original_document_details) return;\n      const details = report.original_document_details;\n      \n      // Check A1 form\n      if (details.social_security_data) {\n          const docType = 'a1_form';\n          const fields = details.social_security_data.additional_fields || {};\n          if (rules[docType]?.requiresStamp && fields.stamp_present === false) compliance.missing_stamps.push(docType);\n          if (rules[docType]?.requiresSignature && fields.signature_present === false) compliance.missing_signatures.push(docType);\n          if (fields.luik_3_2_checked === false && fields.luik_4_1_1_checked === false) {\n              compliance.luik_checkbox_issues.push('A1: Neither Luik 3.2 nor 4.1.1 is checked.');\n          }\n      }\n      // Voeg hier eventueel checks voor andere documenttypes toe.\n    }\n    \n    function calculateWeightedSeverity(flagType, weight) {\n        const baseValues = { 'CRITICAL': 10, 'ERROR': 7, 'WARNING': 4, 'INFO': 1 };\n        return (baseValues[flagType] || 1) * weight;\n    }\n\n    // Geef een gestructureerd rapport terug.\n    return {\n        validation_summary: {\n            overall_status: overallStatus,\n            total_documents: results.length,\n        },\n        flags_and_warnings: combinedFlags.sort((a, b) => b.weighted_severity - a.weighted_severity),\n        recommendations: combinedRecommendations,\n        eu_compliance_check: stampSignatureCompliance,\n        critical_issues_count: totalCriticalIssues,\n        individual_reports: results,\n    };\n}\n\n\n// =================================================================\n// STAP 4: STEL DE FINALE OUTPUT SAMEN\n// =================================================================\n\n// Roep de hoofdfunctie aan om het volledige rapport te genereren.\nconst aiReport = combineValidationResults(validationResults);\n\nlet decision = \"FAIL\";\nlet action = \"reject\";\n\n// De 'overall_status' van het AI-rapport is de enige bron voor de beslissing.\nconst overallStatus = aiReport?.validation_summary?.overall_status;\nconst complianceIssues = aiReport.eu_compliance_check || {};\n\n// Deze switch bepaalt de definitieve 'decision' en 'action'.\nswitch (overallStatus) {\n    case \"PASS\":\n        decision = \"PASS\";\n        action = \"approve\";\n        break;\n    case \"WARNING\":\n        decision = \"REVIEW\";\n        action = \"manual_review\";\n        break;\n    case \"FAIL\":\n        decision = \"FAIL\";\n        action = \"reject\";\n        break;\n    default:\n        decision = \"FAIL\";\n        action = \"reject\";\n}\n\n// Stel de aanbeveling samen: begin met de AI-aanbevelingen.\nlet recommendation_parts = aiReport.recommendations && aiReport.recommendations.length > 0 ? [...aiReport.recommendations] : [];\n\n// Voeg de resultaten van de compliance-check toe als notities, ZONDER de beslissing te wijzigen.\nif (complianceIssues.missing_stamps?.length > 0) {\n    recommendation_parts.push(`Compliance Note: Required stamp(s) missing from: ${[...new Set(complianceIssues.missing_stamps)].join(', ')}. Please verify manually.`);\n}\nif (complianceIssues.missing_signatures?.length > 0) {\n    recommendation_parts.push(`Compliance Note: Required signature(s) missing from: ${[...new Set(complianceIssues.missing_signatures)].join(', ')}. Please verify manually.`);\n}\nif (complianceIssues.luik_checkbox_issues?.length > 0) {\n    recommendation_parts.push(`Compliance Note: ${[...new Set(complianceIssues.luik_checkbox_issues)].join('; ')}. Please verify manually.`);\n}\n\n// Maak de uiteindelijke aanbevelingstekst.\nlet recommendation;\nif (recommendation_parts.length > 0) {\n    recommendation = recommendation_parts.join('; ');\n} else {\n    recommendation = (overallStatus === \"PASS\") ? \"All EU work documents validated successfully.\" : \"See validation report for details.\";\n}\n\n// Maak het finale output-object voor de n8n-node.\nconst output = {\n    decision,\n    action,\n    overall_status: overallStatus,\n    recommendation,\n    eu_compliance_summary: complianceIssues, // De bevindingen worden nog steeds gerapporteerd.\n    full_validation_report: aiReport,      // Het volledige, gedetailleerde rapport.\n};\n\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        432,
        960
      ],
      "id": "c326216c-3c8b-4c17-a101-b1c6e090459d",
      "name": "Code2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://172.17.0.5:3000/forms/libreoffice/convert",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1632,
        320
      ],
      "id": "51b4c3da-cc3d-4959-a8d8-1f7f264f60d1",
      "name": "HTTP Request1"
    }
  ],
  "connections": {
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "json set": {
      "main": [
        [
          {
            "node": "excel 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "On form submission": {
      "main": [
        [
          {
            "node": "Extract Attachments2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract PDF Content Using Gemini Vision": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform to base64": {
      "main": [
        [
          {
            "node": "Extract PDF Content Using Gemini Vision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "create xlsx": {
      "main": [
        []
      ]
    },
    "mail template1": {
      "main": [
        []
      ]
    },
    "mail template": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Send email",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Email1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Attachments2": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "json set",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        []
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Transform to base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        []
      ]
    },
    "Code1": {
      "main": [
        []
      ]
    },
    "excel 3": {
      "main": [
        [
          {
            "node": "mail template",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        []
      ]
    },
    "HTML": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        [
          {
            "node": "Convert to PDF1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to PDF1": {
      "main": [
        []
      ]
    },
    "Code2": {
      "main": [
        []
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "b5e6bb6c-22de-40a4-84d8-679b5b182051",
  "triggerCount": 1,
  "tags": []
}