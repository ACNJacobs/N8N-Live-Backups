{
  "createdAt": "2025-07-22T08:20:42.019Z",
  "updatedAt": "2025-09-02T07:13:37.000Z",
  "id": "zM9trOH14KTomHbp",
  "name": "Subcontract0r review",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "options": {
          "temperature": 0.2
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -1600,
        1872
      ],
      "id": "66bbab92-c59c-49da-9027-5c4022f72425",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "dob7yodE27d15REW",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "function convertIsoToEuropean(dateStr) {\n    if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n        const [year, month, day] = dateStr.split(\"-\");\n        return `${day}/${month}/${year}`;\n    }\n    return dateStr;\n}\n\nfunction convertDatesInObject(obj) {\n    if (Array.isArray(obj)) {\n        return obj.map(convertDatesInObject);\n    } else if (typeof obj === 'object' && obj !== null) {\n        const newObj = {};\n        for (const key in obj) {\n            newObj[key] = convertDatesInObject(obj[key]);\n        }\n        return newObj;\n    } else if (typeof obj === 'string') {\n        return convertIsoToEuropean(obj);\n    } else {\n        return obj;\n    }\n}\n\nconst validationResults = [];\n\nitems.forEach(item => {\n    try {\n        const outputText = item.json.output;\n        const jsonMatch = outputText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n\n        let jsonData;\n        if (jsonMatch && jsonMatch[1]) {\n            jsonData = JSON.parse(jsonMatch[1].trim());\n        } else {\n            jsonData = JSON.parse(outputText.trim());\n        }\n\n        const convertedData = convertDatesInObject(jsonData);\n        validationResults.push(convertedData);\n\n    } catch (e) {\n        console.log('Error parsing AI output:', e.message);\n    }\n});\n\nif (validationResults.length === 0) {\n    return [{\n        json: {\n            decision: \"FAIL\",\n            reason: \"No valid validation results found from AI Agent.\",\n            action: \"reject\",\n            missing_documents: [\"Unable to determine\"],\n            recommendation: \"AI did not produce a valid validation report. Please investigate AI Agent output.\"\n        }\n    }];\n}\n\n// AANGEPAST: De validatieregels voor EU-werkdocumenten zijn bijgewerkt.\nfunction combineValidationResults(results) {\n    const combinedFlags = [];\n    const combinedRecommendations = [];\n    const missingDocuments = [];\n    let overallStatus = \"PASS\";\n    let totalCriticalIssues = 0;\n    \n    // ✅ HERSCHREVEN: De regels voor 'id_card' en 'passport' zijn gecorrigeerd.\n    // De controle op een stempel (requiresStamp) is nu 'false'.\n    const documentTypeRules = {\n        'a1_form': { required: true, priority: 'CRITICAL', criticalWeight: 5, requiresStamp: true, requiresSignature: true },\n        'id_card': { required: true, priority: 'CRITICAL', criticalWeight: 5, requiresStamp: false, requiresSignature: false },\n        'limosa': { required: true, priority: 'CRITICAL', criticalWeight: 4, requiresStamp: false, requiresSignature: false },\n        'svwoh': { required: true, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'certificate': { required: true, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'passport': { required: false, priority: 'HIGH', criticalWeight: 3, requiresStamp: false, requiresSignature: false },\n        'residence_permit': { required: false, priority: 'HIGH', criticalWeight: 3, requiresStamp: true, requiresSignature: false }\n    };\n    \n    // Track alle document types uit alle reports\n    const allDocumentTypes = new Set();\n    const documentsByType = {};\n    const stampSignatureCompliance = {\n        missing_stamps: [],\n        missing_signatures: [],\n        low_confidence_items: [],\n        luik_checkbox_issues: []\n    };\n    \n    console.log(`Processing ${results.length} EU work document validation reports`);\n\n    results.forEach((report, index) => {\n        // Gebruik de overall_status direct van het AI rapport\n        const reportStatus = report.validation_summary?.overall_status;\n        if (reportStatus === \"FAIL\") {\n            overallStatus = \"FAIL\";\n        } else if (reportStatus === \"WARNING\" && overallStatus !== \"FAIL\") {\n            overallStatus = \"WARNING\";\n        }\n\n        // Extract ALL document types uit single report\n        const reportDocumentTypes = extractAllDocumentTypes(report);\n        reportDocumentTypes.forEach(docType => {\n            allDocumentTypes.add(docType);\n            if (!documentsByType[docType]) {\n                documentsByType[docType] = [];\n            }\n            documentsByType[docType].push({ report, index, docType });\n        });\n        \n        // Analyseer compliance per specifiek document type\n        analyzeReportCompliance(report, reportDocumentTypes, stampSignatureCompliance, documentTypeRules);\n        \n        // Verzamel flags met correcte weging\n        if (report.flags_and_warnings) {\n            report.flags_and_warnings.forEach(flag => {\n                // Gebruik gemiddelde weging voor mixed document reports\n                const avgWeight = reportDocumentTypes.reduce((sum, type) => \n                    sum + (documentTypeRules[type]?.criticalWeight || 1), 0) / reportDocumentTypes.length;\n                \n                const weightedFlag = {\n                    ...flag,\n                    document_index: index,\n                    document_type: reportDocumentTypes.join(','),\n                    weighted_severity: calculateWeightedSeverity(flag.type, avgWeight)\n                };\n                combinedFlags.push(weightedFlag);\n            });\n        }\n\n        // EU-specifieke aanbevelingen\n        if (report.recommendations) {\n            const docRecommendations = Array.isArray(report.recommendations) \n                ? report.recommendations \n                : [report.recommendations];\n            docRecommendations.forEach(rec => {\n                combinedRecommendations.push(`[${reportDocumentTypes.join(',').toUpperCase()}] ${rec}`);\n            });\n        }\n\n        // Check kritieke issues\n        const avgWeight = reportDocumentTypes.reduce((sum, type) => \n            sum + (documentTypeRules[type]?.criticalWeight || 1), 0) / reportDocumentTypes.length;\n        const criticalIssues = (report.flags_and_warnings || []).filter(flag =>\n            [\"CRITICAL\", \"ERROR\"].includes(flag.type)\n        ).length;\n        \n        totalCriticalIssues += criticalIssues * avgWeight;\n\n        // Check missing documents\n        if (report.mandatory_documents_check?.all_mandatory_present === \"NO\") {\n            const missing = report.mandatory_documents_check.missing_documents || [];\n            missingDocuments.push(...missing);\n        }\n    });\n    \n    // Extract alle document types uit een report\n    function extractAllDocumentTypes(report) {\n        const types = [];\n        if (report.original_document_details) {\n            const details = report.original_document_details;\n            if (details.social_security_data?.document_type) {\n                types.push(details.social_security_data.document_type);\n            }\n            if (details.identity_document_data?.document_type) {\n                types.push(details.identity_document_data.document_type);\n            }\n            if (details.work_notification_data?.document_type) {\n                types.push(details.work_notification_data.document_type);\n            }\n            if (details.safety_certificate_data?.document_type) {\n                types.push(details.safety_certificate_data.document_type);\n            }\n            if (details.safety_certificate_data_2?.document_type) {\n                types.push(details.safety_certificate_data_2.document_type);\n            }\n        }\n        return types.length > 0 ? types : ['certificate']; // fallback\n    }\n    \n    // Analyseer compliance per report met correcte data reading\n    function analyzeReportCompliance(report, documentTypes, compliance, rules) {\n        if (!report.original_document_details) return;\n        \n        const details = report.original_document_details;\n        \n        // Check social security data (A1)\n        if (details.social_security_data?.additional_fields) {\n            const fields = details.social_security_data.additional_fields;\n            const docType = details.social_security_data.document_type || 'a1_form';\n            const typeRules = rules[docType];\n            \n            if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n            }\n            if (typeRules?.requiresSignature && fields.signature_present === false) {\n                compliance.missing_signatures.push(`${docType}: Required signature missing`);\n            }\n            if (fields.signature_confidence && fields.signature_confidence < 0.5) {\n                compliance.low_confidence_items.push(`${docType}: Low signature confidence (${fields.signature_confidence})`);\n            }\n            if (fields.stamp_confidence && fields.stamp_confidence < 0.5) {\n                compliance.low_confidence_items.push(`${docType}: Low stamp confidence (${fields.stamp_confidence})`);\n            }\n            \n            // Check Luik checkboxes voor A1\n            if (docType === 'a1_form') {\n                if (fields.luik_3_2_checked === false && fields.luik_4_1_1_checked === false) {\n                    compliance.luik_checkbox_issues.push('A1: Neither Luik 3.2 nor 4.1.1 is checked - worker status unclear');\n                }\n            }\n        }\n        \n        // Check identity document\n        if (details.identity_document_data?.additional_fields) {\n            const fields = details.identity_document_data.additional_fields;\n            const docType = details.identity_document_data.document_type || 'id_card';\n            const typeRules = rules[docType];\n            \n            if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n            }\n            if (typeRules?.requiresSignature && fields.signature_present === false) {\n                compliance.missing_signatures.push(`${docType}: Required signature missing`);\n            }\n        }\n        \n        // Check work notification (limosa)\n        if (details.work_notification_data?.additional_fields) {\n            const fields = details.work_notification_data.additional_fields;\n            const docType = details.work_notification_data.document_type || 'limosa';\n            const typeRules = rules[docType];\n            \n            // Limosa typically doesn't require stamps/signatures, so only check if rules say it does\n            if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n            }\n            if (typeRules?.requiresSignature && fields.signature_present === false) {\n                compliance.missing_signatures.push(`${docType}: Required signature missing`);\n            }\n        }\n        \n        // Check safety certificates\n        [details.safety_certificate_data, details.safety_certificate_data_2].forEach((certData, index) => {\n            if (certData?.additional_fields) {\n                const fields = certData.additional_fields;\n                const docType = certData.document_type || 'certificate';\n                const typeRules = rules[docType];\n                \n                if (typeRules?.requiresStamp && fields.stamp_present === false) {\n                    compliance.missing_stamps.push(`${docType}: Required stamp missing`);\n                }\n                if (typeRules?.requiresSignature && fields.signature_present === false) {\n                    compliance.missing_signatures.push(`${docType}: Required signature missing`);\n                }\n            }\n        });\n    }\n    \n    function calculateWeightedSeverity(flagType, weight) {\n        const baseValues = { 'CRITICAL': 10, 'ERROR': 7, 'WARNING': 4, 'INFO': 1 };\n        return (baseValues[flagType] || 1) * weight;\n    }\n    \n    // Creëer correcte type summary gebaseerd op alle gevonden types\n    const typeSummary = Array.from(allDocumentTypes).map(type => ({\n        type,\n        count: documentsByType[type]?.length || 0,\n        required: documentTypeRules[type]?.required || false,\n        status: documentsByType[type] ? getTypeStatus(documentsByType[type]) : 'NOT_FOUND'\n    }));\n\n    function getTypeStatus(documentsOfType) {\n        const statuses = documentsOfType.map(doc => doc.report.validation_summary?.overall_status);\n        if (statuses.includes('FAIL')) return 'FAIL';\n        if (statuses.includes('WARNING')) return 'WARNING';\n        return 'PASS';\n    }\n\n    // Bereken totaal documenten correct\n    const totalDocuments = results.reduce((total, report) => {\n        return total + (report.validation_summary?.documents_validated?.length || 0);\n    }, 0);\n\n    // Voeg alleen echte compliance issues toe als flags\n    stampSignatureCompliance.missing_stamps.forEach(issue => {\n        combinedFlags.push({\n            type: 'CRITICAL',\n            field: 'stamp_compliance',\n            message: issue,\n            document_type: 'compliance_check',\n            weighted_severity: 50\n        });\n    });\n    \n    stampSignatureCompliance.missing_signatures.forEach(issue => {\n        combinedFlags.push({\n            type: 'CRITICAL',\n            field: 'signature_compliance', \n            message: issue,\n            document_type: 'compliance_check',\n            weighted_severity: 45\n        });\n    });\n    \n    stampSignatureCompliance.luik_checkbox_issues.forEach(issue => {\n        combinedFlags.push({\n            type: 'ERROR',\n            field: 'luik_compliance',\n            message: issue,\n            document_type: 'a1_form',\n            weighted_severity: 35\n        });\n    });\n\n    return {\n        validation_summary: {\n            overall_status: overallStatus,\n            total_documents: totalDocuments,\n            documents_processed: totalDocuments,\n            document_types_summary: typeSummary\n        },\n        flags_and_warnings: combinedFlags.sort((a, b) => b.weighted_severity - a.weighted_severity),\n        recommendations: combinedRecommendations,\n        mandatory_documents_check: {\n            all_mandatory_present: missingDocuments.length === 0 ? \"YES\" : \"NO\",\n            missing_documents: missingDocuments\n        },\n        eu_compliance_check: stampSignatureCompliance,\n        critical_issues_count: totalCriticalIssues,\n        individual_reports: results,\n        document_type_breakdown: documentsByType\n    };\n}\n\n// Gebruik gecombineerde resultaten\nconst aiReport = combineValidationResults(validationResults);\n\nlet decision = \"FAIL\";\nlet action = \"reject\";\nlet recommendation = \"No recommendation.\";\n\n// Gebruik AI rapport status als basis, override alleen bij echte problemen\nconst overallStatus = aiReport?.validation_summary?.overall_status;\nconst complianceIssues = aiReport.eu_compliance_check || {};\n\n// Start met AI beslissing\nswitch (overallStatus) {\n    case \"PASS\":\n        decision = \"PASS\";\n        action = \"approve\";\n        break;\n    case \"WARNING\":\n        decision = \"REVIEW\";\n        action = \"manual_review\";\n        break;\n    case \"FAIL\":\n        decision = \"FAIL\";\n        action = \"reject\";\n        break;\n    default:\n        decision = \"FAIL\";\n        action = \"reject\";\n}\n\n// Override alleen bij echte compliance problemen\nconst realStampIssues = complianceIssues.missing_stamps?.length || 0;\nconst realSignatureIssues = complianceIssues.missing_signatures?.length || 0;\nconst realLuikIssues = complianceIssues.luik_checkbox_issues?.length || 0;\n\nif (realStampIssues > 0 || realSignatureIssues > 0) {\n    decision = \"FAIL\";\n    action = \"reject\";\n    recommendation = \"Required stamps or signatures missing from critical EU work documents. Please ensure all documents are properly stamped and signed.\";\n} else if (realLuikIssues > 0) {\n    decision = \"REVIEW\";\n    action = \"manual_review\";\n    recommendation = \"A1 form checkbox issues detected. Manual review required to verify worker employment status.\";\n} else {\n    // Gebruik AI aanbevelingen als er geen compliance issues zijn\n    recommendation = aiReport.recommendations?.join('; ') || \n                     (overallStatus === \"PASS\" ? \"All EU work documents validated successfully.\" : \n                      \"See validation report for details.\");\n}\n\nconst output = {\n    decision,\n    action,\n    overall_status: overallStatus,\n    total_documents_processed: aiReport.validation_summary.total_documents,\n    document_types_found: aiReport.validation_summary.document_types_summary,\n    critical_issues_count: aiReport.critical_issues_count || 0,\n    eu_compliance_summary: complianceIssues,\n    recommendation,\n    missing_documents: aiReport?.mandatory_documents_check?.missing_documents || [],\n    full_validation_report: aiReport\n};\n\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        1632
      ],
      "id": "91a7fec5-a249-401c-8c4f-3449ee8b6306",
      "name": "json set"
    },
    {
      "parameters": {
        "jsCode": "// Met lokale datum formatting:\nconst today = new Date();\nconst validationDate = today.getFullYear() + '-' + \n                      String(today.getMonth() + 1).padStart(2, '0') + '-' + \n                      String(today.getDate()).padStart(2, '0');\n\nreturn items.map(item => {\n  // Combineer ALLE documenten tot 1 string\n  let allDocuments = '';\n  \n  if (item.json.data && Array.isArray(item.json.data)) {\n    item.json.data.forEach((doc, index) => {\n      if (doc.candidates && doc.candidates[0] && doc.candidates[0].content && doc.candidates[0].content.parts && doc.candidates[0].content.parts[0]) {\n        allDocuments += `\\n\\n=== DOCUMENT ${index + 1} ===\\n`;\n        allDocuments += doc.candidates[0].content.parts[0].text;\n        allDocuments += `\\n=== END DOCUMENT ${index + 1} ===\\n`;\n      }\n    });\n  }\n  \n  return {\n    ...item.json,\n    validation_date: validationDate,\n    combined_documents: allDocuments\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        1632
      ],
      "id": "fc11341c-1d4a-4e0f-9b6c-ab7d97bd9c5a",
      "name": "Code"
    },
    {
      "parameters": {
        "formTitle": "Deployment Compliance Checker",
        "formDescription": "=Primary function of checking and verifying the compliance of workers' documents and schedules for deployment on Belgian construction sites.\n\n**Please note:** This system is optimized for PDF documents only. While image files (JPG, PNG, etc.) can be uploaded, they may not always process correctly and could result in errors or incomplete verification. For best results, please convert all documents to PDF format before uploading.\nThe following documents are required:\nID card or passport\nA1 document\nLimosa\nVCA or SCC certificate\n\nIf any of these documents are missing, the result will automatically be marked as a fail.",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Mail",
              "fieldType": "email",
              "placeholder": "Your mail adress here!",
              "requiredField": true
            },
            {
              "fieldLabel": "PDF",
              "fieldType": "file",
              "acceptFileTypes": "PDF",
              "requiredField": true
            }
          ]
        },
        "options": {
          "appendAttribution": false,
          "respondWithOptions": {
            "values": {
              "formSubmittedText": "Response Recorded Thank you for your submission. Your response has been successfully recorded.  Email Notification: You will receive a detailed email response within the next few minutes.  Next Steps: Please check your inbox and spam folder for our response.  Support: If you don't receive an email within 10 minutes, please contact your system administrator.  You may now close this window."
            }
          },
          "customCss": ":root {\n\t--font-family: 'Open Sans', sans-serif;\n\t--font-weight-normal: 400;\n\t--font-weight-bold: 600;\n\t--font-size-body: 12px;\n\t--font-size-label: 16px; /* vergroot van 14px */\n\t--font-size-test-notice: 12px;\n\t--font-size-input: 16px; /* vergroot van 14px */\n\t--font-size-header: 20px;\n\t--font-size-paragraph: 14px;\n\t--font-size-link: 12px;\n\t--font-size-error: 12px;\n\t--font-size-html-h1: 28px;\n\t--font-size-html-h2: 20px;\n\t--font-size-html-h3: 16px;\n\t--font-size-html-h4: 14px;\n\t--font-size-html-h5: 12px;\n\t--font-size-html-h6: 10px;\n\t--font-size-subheader: 14px;\n\t/* Colors - Altrad Theme */\n\t--color-background: #f8f9fa;\n\t--color-test-notice-text: #E31E24;\n\t--color-test-notice-bg: #fef7f7;\n\t--color-test-notice-border: #f5c6c7;\n\t--color-card-bg: #ffffff;\n\t--color-card-border: #e1e5e9;\n\t--color-card-shadow: rgba(227, 30, 36, 0.08);\n\t--color-link: #6b6b6b;\n\t--color-header: #2c2c2c;\n\t--color-label: #2c2c2c;\n\t--color-input-border: #e1e5e9;\n\t--color-input-text: #6b6b6b;\n\t--color-focus-border: #E31E24;\n\t--color-submit-btn-bg: #E31E24;\n\t--color-submit-btn-text: #ffffff;\n\t--color-error: #E31E24;\n\t--color-required: #E31E24;\n\t--color-clear-button-bg: #6b6b6b;\n\t--color-html-text: #2c2c2c;\n\t--color-html-link: #E31E24;\n\t--color-header-subtext: #6b6b6b;\n\t/* Border Radii */\n\t--border-radius-card: 8px;\n\t--border-radius-input: 6px;\n\t--border-radius-clear-btn: 50%;\n\t--card-border-radius: 8px;\n\t/* Spacing */\n\t--padding-container-top: 24px;\n\t--padding-card: 24px;\n\t--padding-test-notice-vertical: 12px;\n\t--padding-test-notice-horizontal: 24px;\n\t--margin-bottom-card: 16px;\n\t--padding-form-input: 18px; /* vergroot van 12px */\n\t--card-padding: 24px;\n\t--card-margin-bottom: 16px;\n\t/* Dimensions */\n\t--container-width: 520px; /* vergroot van 448px */\n\t--submit-btn-height: 56px; /* vergroot van 48px */\n\t--checkbox-size: 18px;\n\t/* Others */\n\t--box-shadow-card: 0px 4px 16px 0px var(--color-card-shadow);\n\t--opacity-placeholder: 0.5;\n\t/* Logo */\n\t--logo-url: url('https://bnl.altradservices.com/assets/images/b/Benelux_RVB-660c4912.jpg');\n}"
        }
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        -2304,
        1344
      ],
      "id": "009c2647-82dc-452a-b28f-7dfa4ae138fd",
      "name": "On form submission",
      "webhookId": "9e3bfff9-b57f-408f-8414-8064628edd98",
      "retryOnFail": true
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        -2096,
        1632
      ],
      "id": "3a016a1b-86a2-4ebe-8afd-a4d895675306",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [\n    {\n      \"parts\": [\n        {\n          \"text\": \"CRITICAL: YOU MUST EXTRACT EVERY SINGLE PIECE OF INFORMATION FROM THE DOCUMENT. DO NOT SKIP OR IGNORE ANY TEXT, NUMBERS, DATES, OR DETAILS.\\n\\nYou will receive official documents. These may include passports, ID cards, residence permits, work permits, A1 forms, Limosa declarations, VCA, SVWOH, SCC certificates, diplomas, training certificates, and professional qualifications.\\n\\nMANDATORY EXTRACTION REQUIREMENTS:\\n- Extract ALL visible text, including headers, footers, watermarks, and small print\\n- Extract ALL numbers, including reference numbers, serial numbers, and codes\\n- Extract ALL dates, even if they appear multiple times or in different formats\\n- Extract ALL names, including variations, abbreviations, and partial names\\n- Extract ALL addresses and locations\\n- Extract ALL stamps, signatures, and official markings\\n- Extract ALL checkbox states and form field values\\n- Do NOT make assumptions - if you see text, extract it\\n- Do NOT summarize or condense information - include everything verbatim\\n\\nSome individuals are nationals of third countries and will submit more documents. Handle all documents equally and return structured output per document.\\n\\nIf a document spans multiple pages, detect that they belong together based on layout, headers, document number, or visual consistency. Return a single merged JSON object with combined data and concatenated raw_text field.\\n\\nVisually inspect the entire document for official stamps and handwritten signatures. These are crucial for document validity. Populate stamp_present and signature_present fields accurately.\\n\\nExamine all documents for checked boxes or marked text fields, particularly in A1 forms where specific sections may be checked. Pay attention to Luik 3.2 and Luik 4.1.1 as these are critical indicators.\\n\\nAt the top level of the response, return two additional fields:\\n\\n1. person_check: an object containing:\\n   - same_person (boolean): whether all documents likely belong to the same individual\\n   - cross_document_name_match_score (float): average name similarity score (0.0-1.0)\\n   - name_variants (array): all unique detected full name variants\\n\\n2. documents_check: an object containing:\\n   - required_documents (array): based on nationality, list required document types\\n   - present_documents (array): list of all detected document types\\n   - missing_required_documents (array): required types that were not found\\n   - all_required_documents_present (boolean): true if nothing is missing\\n\\nThen return documents as a JSON array, where each document is one object.\\n\\nEach document must include these fields (attempt to fill EVERY field):\\n- document_type (REQUIRED)\\n- country_of_origin (REQUIRED)\\n- full_name (REQUIRED)\\n- date_of_birth (format: YYYY-MM-DD, derive from ID numbers if needed)\\n- document_number (REQUIRED)\\n- expiry_date (REQUIRED)\\n- certificate_id\\n- diploma_title\\n- employer_name\\n- employment_period\\n- exam_date\\n- valid_until\\n- stamp_present: true or false\\n- stamp_confidence: float (0.0-1.0)\\n- signature_present: true or false\\n- signature_confidence: float (0.0-1.0)\\n- validation_date: string or null\\n- additional_numbers: array of ALL other numbers found\\n- additional_dates: array of ALL other dates found\\n- additional_text: array of ANY other important text\\n- raw_text: COMPLETE OCR output containing EVERY visible word, number, and character\\n\\nFor A1 documents, include a1_structured field with:\\n- checkboxes: object with boolean and confidence for keys like 3.1, 3.2, 4.1.1, 4.1.2\\n- sections: capture verbatim list-lines for 5.1 and 5.2\\n- checkbox_evidence: array of evidence objects per tick\\n\\nSPECIAL SCC VALIDATION:\\nFor SCC certificates, add:\\n- scc_number: extracted SCC number (e.g. 016, 018)\\n- scc_validation object with:\\n  - number_found (boolean)\\n  - number_value (string)\\n  - number_confidence (float)\\n  - valid_format (boolean)\\n  - common_scc_types (array)\\n\\nThe date_of_birth is critical for ID cards and passports. If not explicitly labeled, search for national identification numbers that embed the date in YYMMDD format. Extract, interpret, and normalize to YYYY-MM-DD format.\\n\\nCOMPLETENESS CHECK - BEFORE FINALIZING:\\n1. Re-scan the entire document image one more time\\n2. Verify you have extracted EVERY visible piece of text\\n3. Confirm you have not missed any numbers, dates, names, or codes\\n4. Double-check all corners, headers, footers, and margins\\n5. Ensure the raw_text field contains 100% of visible content\\n6. If you find anything you missed, ADD IT to your response\\n\\nReturn only valid JSON with no explanations, markdown, or formatting.\"\n        },\n        {\n          \"inline_data\": {\n            \"mime_type\": \"application/pdf\",\n            \"data\": \"{{$json.data}}\"\n          }\n        }\n      ]\n    }\n  ]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2336,
        1632
      ],
      "id": "c48bac37-ff61-4cbb-b505-8d73123b21ad",
      "name": "Extract PDF Content Using Gemini Vision",
      "credentials": {
        "httpQueryAuth": {
          "id": "t6Npfn3CB5NrgzCP",
          "name": "Query Auth account"
        }
      }
    },
    {
      "parameters": {
        "operation": "binaryToPropery",
        "destinationKey": "=data",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -1184,
        1328
      ],
      "id": "8cb2d567-c955-4c97-919c-50c472748a77",
      "name": "Transform to base64"
    },
    {
      "parameters": {
        "jsCode": "\n\n// DYNAMIC AND ROBUST VERSION - Processes variable number of documents\nconst inputData = $input.first().json;\n\n// --- Helper Functions ---\nfunction getValue(obj, path, defaultValue = 'N/A') {\n    try {\n        const value = path.split('.').reduce((acc, key) => acc && acc[key], obj);\n        return value !== undefined && value !== null ? value : defaultValue;\n    } catch {\n        return defaultValue;\n    }\n}\n\nfunction formatArray(arr) {\n    if (Array.isArray(arr)) {\n        return arr.join(', ');\n    }\n    return arr || 'N/A';\n}\n\nfunction calculateAge(birthDate) {\n    if (!birthDate || birthDate === 'N/A') return 'N/A';\n    try {\n        // Tries DD/MM/YYYY and YYYY-MM-DD\n        let date;\n        if (birthDate.includes('/')) {\n            const parts = birthDate.split('/');\n            date = new Date(parts[2], parts[1] - 1, parts[0]);\n        } else if (birthDate.includes('-')) {\n            date = new Date(birthDate);\n        } else {\n            return 'N/A';\n        }\n        \n        const today = new Date();\n        let age = today.getFullYear() - date.getFullYear();\n        const m = today.getMonth() - date.getMonth();\n        if (m < 0 || (m === 0 && today.getDate() < date.getDate())) {\n            age--;\n        }\n        return isNaN(age) ? 'N/A' : age;\n    } catch {\n        return 'N/A';\n    }\n}\n\n// Function to generate HTML card for ANY document type - fully dynamic\nfunction renderDocumentCard(category, doc, index = 0) {\n    const data = doc || {};\n    \n    // Create human-readable title from category name\n    let baseTitle = category.replace(/_data$/, '').replace(/_/g, ' ')\n                           .replace(/\\b\\w/g, l => l.toUpperCase());\n    \n    // Add index if there are multiple documents of the same type\n    const title = index > 0 ? `${baseTitle} ${index + 1}` : baseTitle;\n    \n    // Special title mappings for common document types\n    const titleMappings = {\n        'Social Security': 'A1 Social Security Certificate',\n        'Identity Document': 'Identity Document',\n        'Work Notification': 'Work Notification',\n        'Safety Certificate': 'Safety Certificate',\n        'Professional Certificate': 'Professional Certificate',\n        'Training Certificate': 'Training Certificate'\n    };\n    \n    let finalTitle = titleMappings[baseTitle] || baseTitle;\n    \n    // Special handling for identity documents - show ID Card or Passport\n    if (category === 'identity_document_data' && data.document_type) {\n        const docType = data.document_type.toLowerCase();\n        if (docType.includes('passport')) {\n            finalTitle = index > 0 ? `Passport ${index + 1}` : 'Passport';\n        } else if (docType.includes('id') || docType.includes('identity')) {\n            finalTitle = index > 0 ? `ID Card ${index + 1}` : 'ID Card';\n        } else {\n            // Use the actual document type if available\n            finalTitle = index > 0 ? `${data.document_type} ${index + 1}` : data.document_type;\n        }\n    }\n    \n    // Generate details dynamically from all available fields\n    let details = '';\n    \n    // Define field display mappings and priorities\n    const fieldMappings = {\n        // Common fields\n        'document_type': 'Document Type',\n        'document_number': 'Document Number',\n        'certificate_number': 'Certificate Number',\n        'expiry_date': 'Expiry Date',\n        'issue_date': 'Issue Date',\n        'issuing_country': 'Issuing Country',\n        'issuing_authority': 'Issuing Authority',\n        \n        // Personal info\n        'worker_name': 'Worker Name',\n        'holder_name': 'Holder Name',\n        'employee_name': 'Employee Name',\n        'given_names': 'Given Names',\n        'surname': 'Surname',\n        'birth_date': 'Date of Birth',\n        'nationality': 'Nationality',\n        'gender': 'Gender',\n        'personal_identifier': 'Personal ID',\n        \n        // Work-related\n        'work_period_start': 'Work Period Start',\n        'work_period_end': 'Work Period End',\n        'sending_company': 'Sending Company',\n        'employer_name': 'Employer',\n        'work_location': 'Work Location',\n        'sector': 'Sector',\n        'profession': 'Profession',\n        'notification_country': 'Notification Country',\n        \n        // Certificate specific\n        'certificate_type': 'Certificate Type',\n        'issue_place': 'Issue Place',\n        'exam_language': 'Exam Language',\n        'validity_period': 'Validity Period',\n        'training_provider': 'Training Provider',\n        \n        // Additional\n        'director_manager': 'Director/Manager',\n        'receiving_companies': 'Receiving Companies'\n    };\n    \n    // Priority order for displaying fields\n    const fieldPriority = [\n        'document_type', 'certificate_type', 'document_number', 'certificate_number',\n        'worker_name', 'holder_name', 'employee_name', 'given_names', 'surname',\n        'work_period_start', 'work_period_end', 'expiry_date', 'issue_date',\n        'employer_name', 'sending_company', 'work_location', 'sector',\n        'issuing_country', 'issuing_authority', 'nationality', 'birth_date',\n        'personal_identifier', 'gender', 'profession', 'notification_country',\n        'issue_place', 'exam_language', 'director_manager', 'receiving_companies'\n    ];\n    \n    // Process fields in priority order first\n    for (const field of fieldPriority) {\n        if (data[field] !== undefined && data[field] !== null && data[field] !== '') {\n            const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            let value = data[field];\n            \n            // Format arrays nicely\n            if (Array.isArray(value)) {\n                value = formatArray(value);\n            }\n            \n            details += `<p><strong>${displayName}:</strong> ${value}</p>\\n                `;\n        }\n    }\n    \n    // Add any remaining fields not in priority list\n    for (const [field, value] of Object.entries(data)) {\n        if (!fieldPriority.includes(field) && \n            field !== 'additional_fields' && \n            value !== undefined && value !== null && value !== '') {\n            \n            const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            let displayValue = value;\n            \n            if (Array.isArray(displayValue)) {\n                displayValue = formatArray(displayValue);\n            } else if (typeof displayValue === 'object') {\n                // Skip complex objects for now\n                continue;\n            }\n            \n            details += `<p><strong>${displayName}:</strong> ${displayValue}</p>\\n                `;\n        }\n    }\n    \n    // Add additional_fields if they exist\n    if (data.additional_fields && typeof data.additional_fields === 'object') {\n        for (const [field, value] of Object.entries(data.additional_fields)) {\n            if (value !== undefined && value !== null && value !== '') {\n                const displayName = fieldMappings[field] || field.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                details += `<p><strong>${displayName}:</strong> ${value}</p>\\n                `;\n            }\n        }\n    }\n    \n    // If no details were generated, show a generic message\n    if (!details.trim()) {\n        details = '<p>No detailed information available for this document.</p>';\n    }\n    \n    return `<div class=\"info-card\"><h4>${finalTitle}</h4>${details}</div>`;\n}\n\n// --- Data Extraction ---\nconst decision = getValue(inputData, 'decision', 'UNKNOWN');\nconst overallStatus = getValue(inputData, 'overall_status', 'UNKNOWN');\nconst validationData = getValue(inputData, 'full_validation_report', {});\nconst firstReport = getValue(validationData, 'individual_reports.0', {});\n\n// Get all original document details\nconst originalDocs = getValue(firstReport, 'original_document_details', {});\n\n// Extract data objects/arrays for easy access - FULLY DYNAMIC\nconst personalData = getValue(firstReport, 'personal_data_comparison', {});\n\n// Create a flat array of ALL documents for easier searching\nconst allDocuments = [];\nfor (const [category, docData] of Object.entries(originalDocs)) {\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        documents.forEach(doc => {\n            if (doc) {\n                allDocuments.push({ category, ...doc });\n            }\n        });\n    }\n}\n\n// Dynamic employee information extraction - searches through ALL documents\nfunction findFieldInDocuments(fieldNames, fallback = 'N/A') {\n    // First try personal data comparison\n    for (const fieldName of fieldNames) {\n        const personalValue = getValue(personalData, `${fieldName}.social_security_doc`) ||\n                             getValue(personalData, `${fieldName}.identity_doc`) ||\n                             getValue(personalData, `${fieldName}.work_notification`);\n        if (personalValue && personalValue !== 'N/A') return personalValue;\n    }\n    \n    // Then search through all documents\n    for (const fieldName of fieldNames) {\n        for (const doc of allDocuments) {\n            if (doc[fieldName] && doc[fieldName] !== 'N/A') {\n                return doc[fieldName];\n            }\n        }\n    }\n    \n    // Special handling for combined names\n    if (fieldNames.includes('worker_name')) {\n        for (const doc of allDocuments) {\n            if (doc.given_names && doc.surname) {\n                return `${doc.given_names} ${doc.surname}`.trim();\n            }\n        }\n    }\n    \n    return fallback;\n}\n\nconst workerName = findFieldInDocuments(['worker_name', 'holder_name', 'employee_name', 'given_names']);\nconst birthDate = findFieldInDocuments(['birth_date']);\nconst personalId = findFieldInDocuments(['personal_identifier', 'employee_identification']);\nconst nationality = findFieldInDocuments(['nationality']);\nconst profession = findFieldInDocuments(['profession', 'sector']);\nconst age = calculateAge(birthDate);\n\n// Document status - DYNAMIC based on what's actually present\nconst mandatoryDocs = getValue(firstReport, 'mandatory_documents_check', {});\n\n// Create dynamic document status overview\nlet documentStatusHtml = '';\nconst documentCounts = {};\n\n// Count all document types\nfor (const category in originalDocs) {\n    const docData = originalDocs[category];\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        const validDocs = documents.filter(doc => doc && Object.keys(doc).length > 0);\n        if (validDocs.length > 0) {\n            documentCounts[category] = validDocs.length;\n        }\n    }\n}\n\n// Generate status for each document type found\nfor (const [category, count] of Object.entries(documentCounts)) {\n    const displayName = category.replace(/_data$/, '').replace(/_/g, ' ')\n                               .replace(/\\b\\w/g, l => l.toUpperCase());\n    const status = count > 0 ? '✓ Present' : '✗ Missing';\n    const countText = count > 1 ? ` (${count} documents)` : '';\n    documentStatusHtml += `<p><strong>${displayName}:</strong> ${status}${countText}</p>\\n            `;\n}\n\n// Also check mandatory document status if available\nconst mandatoryStatusMapping = {\n    'social_security_document_present': 'Social Security Document',\n    'identity_document_present': 'Identity Document', \n    'work_notification_present': 'Work Notification',\n    'safety_certificate_present': 'Safety Certificate',\n    'professional_certificate_present': 'Professional Certificate'\n};\n\nfor (const [key, displayName] of Object.entries(mandatoryStatusMapping)) {\n    if (mandatoryDocs[key] !== undefined) {\n        // Only show if not already covered by document counts\n        const category = displayName.toLowerCase().replace(/\\s+/g, '_') + '_data';\n        if (!documentCounts[category]) {\n            const status = mandatoryDocs[key] === 'YES' ? '✓ Present' : '✗ Missing';\n            documentStatusHtml += `<p><strong>${displayName}:</strong> ${status}</p>\\n            `;\n        }\n    }\n}\n\n// --- Dynamic HTML Generation ---\n\n// Generate HTML for all document cards - FULLY DYNAMIC with identity documents first\nlet documentDetailsHtml = '';\n\n// First, render identity documents (ID cards/passports) at the top\nif (originalDocs['identity_document_data']) {\n    const identityData = originalDocs['identity_document_data'];\n    const identityDocuments = Array.isArray(identityData) ? identityData : [identityData];\n    \n    identityDocuments.forEach((doc, index) => {\n        if (doc && Object.keys(doc).length > 0) {\n            documentDetailsHtml += renderDocumentCard('identity_document_data', doc, index);\n        }\n    });\n}\n\n// Then render all other document types\nfor (const category in originalDocs) {\n    // Skip identity documents as they're already rendered\n    if (category === 'identity_document_data') continue;\n    \n    const docData = originalDocs[category];\n    if (docData) {\n        const documents = Array.isArray(docData) ? docData : [docData];\n        \n        documents.forEach((doc, index) => {\n            if (doc && Object.keys(doc).length > 0) {\n                documentDetailsHtml += renderDocumentCard(category, doc, index);\n            }\n        });\n    }\n}\n\n// Consistency checks\nconst consistency = {\n    name: getValue(personalData, 'name.status', 'UNKNOWN'),\n    birthDate: getValue(personalData, 'birth_date.status', 'UNKNOWN'),\n    personalId: getValue(personalData, 'personal_identifier.status', 'UNKNOWN'),\n    nationality: getValue(personalData, 'nationality.status', 'UNKNOWN')\n};\nconst crossConsistency = getValue(firstReport, 'cross_document_consistency', {});\n\n// Flags, warnings and recommendations\nconst flags = getValue(validationData, 'flags_and_warnings', []);\nconst recommendations = getValue(validationData, 'recommendations', []);\n\n// Status for display\nlet statusClass, statusIcon;\nswitch (decision) {\n    case 'PASS': statusClass = 'pass'; statusIcon = '✓'; break;\n    case 'REVIEW': statusClass = 'warning'; statusIcon = '⚠'; break;\n    case 'FAIL': statusClass = 'fail'; statusIcon = '✗'; break;\n    default: statusClass = 'unknown'; statusIcon = '?';\n}\n\n// Generate the complete HTML report\nconst htmlReport = `\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; line-height: 1.6; color: #333; }\n        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n        .header { text-align: center; border-bottom: 3px solid #007bff; padding-bottom: 20px; margin-bottom: 30px; }\n        .header h1 { color: #007bff; margin: 0; font-size: 28px; }\n        .status-pass { background: #d4edda; color: #155724; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-fail { background: #f8d7da; color: #721c24; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-warning { background: #fff3cd; color: #856404; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .status-unknown { background: #e2e3e5; color: #383d41; padding: 8px 16px; border-radius: 20px; font-weight: bold; display: inline-block; font-size: 1.1em; margin-top: 10px; }\n        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 20px; }\n        .info-card { background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff; }\n        .info-card h4 { margin: 0 0 10px 0; color: #495057; font-size: 1.1em; border-bottom: 1px solid #ddd; padding-bottom: 5px; }\n        .info-card p { margin: 5px 0; font-size: 0.95em; word-wrap: break-word; }\n        table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 0.9em; }\n        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }\n        th { background: #e9ecef; font-weight: bold; color: #495057; }\n        .match { color: #28a745; font-weight: bold; }\n        .mismatch { color: #dc3545; font-weight: bold; }\n        .section { margin-bottom: 35px; }\n        .section h2, .section h3 { color: #007bff; border-bottom: 2px solid #e9ecef; padding-bottom: 8px; margin-bottom: 15px; font-size: 1.4em; }\n        .section h3 { font-size: 1.2em; }\n        .highlight { background: #e7f3ff; padding: 20px; border-radius: 8px; border-left: 5px solid #17a2b8; margin-top: 30px; }\n        .highlight h3 { color: #17a2b8; margin-top: 0; }\n        .warning-item, .error-item, .critical-item { padding: 10px; margin: 5px 0; border-radius: 4px; border-left-width: 5px; border-left-style: solid; }\n        .warning-item { background: #fff3cd; border-left-color: #ffeeba; }\n        .error-item { background: #f8d7da; border-left-color: #f5c6cb; }\n        .critical-item { background: #f8d7da; color: #721c24; font-weight: bold; border-left-color: #dc3545; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>📋 Document Validation Report</h1>\n            <div class=\"status-${statusClass}\">${statusIcon} ${decision}</div>\n            <p><strong>Date:</strong> ${new Date().toLocaleDateString('en-US')} | <strong>Status:</strong> ${overallStatus}</p>\n        </div>\n        \n        <div class=\"section\">\n            <h2>👤 Employee Information</h2>\n            <div class=\"info-card\">\n                <div class=\"info-grid\">\n                    <div><p><strong>Name:</strong> ${workerName}</p></div>\n                    <div><p><strong>Date of Birth:</strong> ${birthDate}</p></div>\n                    <div><p><strong>Age:</strong> ${age} years</p></div>\n                    <div><p><strong>Personal ID:</strong> ${personalId}</p></div>\n                    <div><p><strong>Nationality:</strong> ${nationality}</p></div>\n                    <div><p><strong>Profession:</strong> ${profession}</p></div>\n                </div>\n            </div>\n        </div>\n\n        <div class=\"section\">\n            <h3>📋 Document Status Overview</h3>\n            ${documentStatusHtml}\n        </div>\n\n        <div class=\"section\">\n            <h2>📄 Document Details</h2>\n            <div class=\"info-grid\">\n                ${documentDetailsHtml}\n            </div>\n        </div>\n        \n        <div class=\"section\">\n            <h3>🔍 Data Consistency</h3>\n            <table>\n                <tr><th>Field</th><th>Status</th></tr>\n                <tr><td>Name</td><td class=\"${consistency.name === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.name || 'N/A'}</td></tr>\n                <tr><td>Date of Birth</td><td class=\"${consistency.birthDate === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.birthDate || 'N/A'}</td></tr>\n                <tr><td>Personal ID</td><td class=\"${consistency.personalId === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.personalId || 'N/A'}</td></tr>\n                <tr><td>Nationality</td><td class=\"${consistency.nationality === 'MATCH' ? 'match' : 'mismatch'}\">${consistency.nationality || 'N/A'}</td></tr>\n                <tr><td>Work Periods</td><td class=\"${crossConsistency.work_periods_align === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.work_periods_align || 'N/A'}</td></tr>\n                <tr><td>Employer</td><td class=\"${crossConsistency.employer_consistency === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.employer_consistency || 'N/A'}</td></tr>\n                <tr><td>Location</td><td class=\"${crossConsistency.location_consistency === 'YES' ? 'match' : 'mismatch'}\">${crossConsistency.location_consistency || 'N/A'}</td></tr>\n            </table>\n        </div>\n        \n        ${flags.length > 0 ? `\n        <div class=\"section\">\n            <h3>🚨 Issues & Warnings Found</h3>\n            ${flags.map(flag => `\n                <div class=\"${flag.type.toLowerCase()}-item\">\n                    <strong>${flag.type}:</strong> ${flag.message}\n                    ${flag.field ? `<em>(Field: ${flag.field})</em>` : ''}\n                </div>\n            `).join('')}\n        </div>\n        ` : ''}\n\n        ${recommendations.length > 0 ? `\n        <div class=\"highlight\">\n            <h3>💼 Recommendations</h3>\n            <ul>\n                ${recommendations.map(rec => `<li>${rec}</li>`).join('')}\n            </ul>\n        </div>\n        ` : ''}\n    </div>\n</body>\n</html>\n`;\n\n// Get all binary data (original documents)\nconst allBinaryAttachments = $input.first().binary || {};\n\n// Return the output\nreturn [{\n    json: {\n        html_report: htmlReport,\n        subject: `Document Validation - ${workerName} - ${decision}`,\n        worker_name: workerName,\n        decision: decision,\n        toEmail: getValue(inputData, 'originalEmail.from.address', 'fallback@email.com'),\n        validation_data_json: validationData\n    },\n    //binary: allBinaryAttachments\n    binary: $input.first().binary || {} \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2304,
        2048
      ],
      "id": "f71d9d20-2882-4761-a531-1d980f0a34c7",
      "name": "mail template"
    },
    {
      "parameters": {
        "fromEmail": "ai@go-knowledge.nl",
        "toEmail": "={{ $('On form submission').item.json.Mail }}",
        "subject": "Failure Subcontracter screening ",
        "html": "={{ $json.html_report }}",
        "options": {
          "appendAttribution": false,
          "attachments": "={{ Object.keys($binary).join(\",\") }}"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        -1856,
        2144
      ],
      "id": "1d739e0e-6e5a-4bf4-b969-f6ff537dad1a",
      "name": "Send Email1",
      "webhookId": "72b63045-27e2-4305-9aef-76f16ca3b1b2",
      "credentials": {
        "smtp": {
          "id": "yG4Ihfi7vhKZzG49",
          "name": "ai@go-knowledge"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "40c2daca-0a33-46ea-b3c7-7ef41f9a4c56",
              "leftValue": "={{ $json.decision }}",
              "rightValue": "PASS",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2080,
        2048
      ],
      "id": "e6ef18e9-9b0b-4eca-93ab-dc22f44aa42b",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "const results = [];\nconst inputItems = $input.all();\n\nfor (const item of inputItems) {\n  if (item.binary) {\n    for (const [key, bin] of Object.entries(item.binary)) {\n      const fileName = bin.fileName?.toLowerCase() || '';\n      const mimeType = bin.mimeType?.toLowerCase() || '';\n\n      const isAttachment = key.startsWith('attachment_') || \n                           key.includes('attachment') || \n                           key.startsWith('data_') ||\n                           bin.fileName;\n\n      // Herkenbare extensies\n      const isPdf = mimeType === 'application/pdf' || fileName.endsWith('.pdf');\n      const isJpg = mimeType === 'image/jpeg' || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg');\n      const isPng = mimeType === 'image/png' || fileName.endsWith('.png');\n\n      const isAllowedFile = isPdf || isJpg || isPng;\n\n      if (isAttachment && isAllowedFile) {\n        results.push({\n          binary: {\n            data: bin,\n          },\n          json: {\n            fileName: bin.fileName || `attachment_${key}`,\n            mimeType: bin.mimeType || 'unknown',\n            originalKey: key,\n          },\n        });\n      }\n    }\n  }\n}\n\nreturn results.length > 0 ? results : [{\n  json: {\n    error: 'Geen PDF of afbeeldingsbestanden gevonden',\n    tip: 'Controleer of er PDF/JPG/PNG-bijlagen in de e-mail zitten en of de e-mail correct is verwerkt'\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2080,
        1344
      ],
      "id": "c18392d0-b7a8-4c43-9195-3c45ba03353a",
      "name": "Extract Attachments2",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Information regarding signatures or stamps must be returned/included with validation_date - this information is included in the accompanying data that I am providing.  = {{ $json.validation_date }}\n\n{{ $json.combined_documents }}",
        "options": {
          "systemMessage": "=You will receive multiple JSON documents for the same person from ANY European Union country. Perform strict cross-document validation and create a comprehensive validation report with ALL document details.\n\n## **MANDATORY DOCUMENTS (ALL REQUIRED):**\n\n- A1/Social Security Certificate (EU regulation 883/2004) OR equivalent national document\n- National Identity Card OR Passport\n- Work Notification (Limosa/A1/National equivalent) \n- Safety/Professional Certificate (VCA/DGUV/National equivalent)\n\n## **EUROPEAN DOCUMENT VARIATIONS:**\n\n- **Identity:** ID Card, Passport, National Identity Document\n- **Personal Numbers:** BSN (NL), PESEL (PL), Personal Code (LT), Social Security Number, etc.\n- **Work Permits:** A1, A28, Limosa, National work declarations\n- **Safety Certs:** VCA (NL/BE), DGUV (DE), National safety certificates\n\n## PERSONAL IDENTIFIER VALIDATION LOGIC (GENERALIZED, AT SCALE)\n\n### Identifier taxonomy\nClassify every identifier into exactly ONE of these classes:\n\nA. National Personal Identifier (NPI)\n   - Government-issued person identifiers used across national systems.\n   - Examples (non-exhaustive): “Personal Code”, “National ID number”, “Social Security Number”, “BSN”, “PESEL”, “CNP”, “Asmens kodas”, etc.\n   - MAY also appear on identity documents (e.g., residence permit shows both a document number and the NPI).\n\nB. Travel/Identity Document Number (ID-DOC)\n   - The number of the passport, national ID card, or residence permit.\n   - This is a document identifier, not an NPI.\n\nC. Administrative/Process Identifier (ADMIN)\n   - Numbers tied to a specific procedure or certificate: notification numbers, declaration/registration/application numbers, work/employee codes, sector/certificate numbers, social-security form reference numbers, etc.\n\nD. Company/Organization Identifier (ORG)\n   - Numbers identifying organizations (e.g., tax/VAT, chamber-of-commerce/business register numbers).\n\n### Extraction rules\n1) Extract ALL identifiers you see, but store them under their class (NPI, ID-DOC, ADMIN, ORG).  \n2) For identity documents, extract BOTH:\n   - `document_number` → class ID-DOC\n   - `national_personal_identifier` (if present) → class NPI\n3) Do NOT overwrite or conflate fields from different classes.\n\n### Comparison rules\n1) Cross-document comparison is ONLY allowed within the SAME class:\n   - NPI ↔ NPI → produce MATCH/MISMATCH.\n   - ID-DOC ↔ ID-DOC → optional comparison (only if the same document appears in multiple files); otherwise just PRESENT.\n   - ADMIN, ORG → NEVER compared; always reported as PRESENT only.\n2) Under NO circumstances compare across classes (e.g., ADMIN vs NPI, ID-DOC vs NPI).  \n   - Differences across classes can NEVER trigger FAIL.\n3) If an ADMIN identifier encodes a birth date, you may use it ONLY to cross-check the birth_date field:\n   - If inconsistent with primary documents, raise WARNING (not FAIL), unless primary documents themselves conflict.\n\n### Failure policy (identifiers)\n- A FAIL may be caused by NPI MISMATCH across authoritative person documents (clear different person).\n- A FAIL may NOT be caused by:\n  - Any difference between ADMIN and NPI,\n  - Any difference between ID-DOC and NPI,\n  - Missing ADMIN/ORG identifiers.\n\n### Normalization\n- Before comparing, normalize by removing spaces, punctuation and formatting, and compare case-insensitive.\n\n\n\n\n- **ACTION:** The final output must be a summary object that lists each unique type of identifier found, its value, its own comparison status (`MATCH`, `MISMATCH`, or `PRESENT`), and the source documents.\n\n## **CRITICAL VALIDATION RULES:**\n\n- Identifiers from different classes (NPI, ID-DOC, ADMIN, ORG) may never be cross-matched. \n  Any attempt to compare across classes is a validation error and must be ignored. \n  FAIL can only result from mandatory document rules, expiries, and NPI conflicts across authoritative person documents.\n\n\n- If ANY of the 4 mandatory document types is missing → overall_status = \"FAIL\"\n- **If ANY document is expired as of the determined validation date → overall_status = \"FAIL\"**\n- **If A1/social security work period has ended relative to the determined validation date → overall_status = \"FAIL\"**\n- **If safety certificate is expired relative to the determined validation date → overall_status = \"FAIL\"**\n- **If identity document is expired relative to the determined validation date → overall_status = \"FAIL\"**\n- **If work notification period has ended relative to the determined validation date → overall_status = \"FAIL\"**\n- Compare personal data across all documents (accounting for different formats)\n- Check for inconsistencies in names, dates, numbers\n- Verify document validity periods overlap with work periods, considering **future start dates are permissible if the document is formally submitted/issued at or before the determined validation date**.\n- **ALL documents must be currently valid as per their submission/issue date on or before the determined validation date, and their validity period must cover any relevant work period starting from or after the determined validation date.**\n- Flag suspicious patterns\n- PRESERVE ALL original document details regardless of country format\n\n#SPECIAL RULES — STAMPS ON IDENTITY DOCUMENTS\n- For document_type in { \"passport\", \"id_card\", \"identity_card\", \"residence_permit\" } (case-insensitive, synonyms included):\n  - Ignore fields: stamp_present, stamp_confidence, stamp_required, stamp_compliance (if present).\n  - Do NOT generate any WARNING or CRITICAL related to stamps for these documents.\n  - If your pipeline computes a \"stamp_compliance\" field globally, set it to \"NOT_APPLICABLE\" for these identity documents.\n\n\n## **MANDATORY FAILURE CONDITIONS:**\n\n- **Missing social security/A1 equivalent → FAIL**\n- **Missing identity document → FAIL** - **Missing work notification → FAIL**\n- **Missing safety certificate → FAIL**\n- **ANY document expired as of the determined validation date → FAIL**\n- **A1/Social security certificate work period ended relative to the determined validation date → FAIL**\n- **Safety certificate expired relative to the determined validation date → FAIL**\n- **Identity document expired relative to the determined validation date → FAIL**\n- **Work notification period ended relative to the determined validation date → FAIL**\n- Documents expired during work period relative to the determined validation date → FAIL\n- Non-EU citizen without proper work authorization → FAIL\n- **The determined validation date falls outside any document's overall submission/validity timeframe. For work-specific documents (A1, Work Notification), if their formal 'sent' or 'issue date' is *after* the determined validation date, it's a FAIL.**\n\n## **DATE VALIDATION REQUIREMENTS:**\n\n1.  **Determine Validation Date:** The AI must first establish a 'validation_date'.\n    * If a 'validation_date' is explicitly provided in the input, use that.\n    * Otherwise, the AI must infer the 'validation_date' as the **earliest 'notification sent on' or 'issue date'** (e.g., Limosa 'Melding verstuurd op', A1 application date) across all provided *work authorization related documents*.\n    * If no such 'notification sent on' or 'issue date' can be inferred, then use the **earliest 'work_period_start' date** from either the A1/Social Security Certificate or the Work Notification (Limosa/National equivalent) across all provided documents.\n    * If no suitable date can be inferred from the documents, the AI should use the **current actual date** as the 'validation_date'.\n    * **Crucially, if an A1 certificate application is provided and is signed, the AI must consider the worker eligible to commence work from its stated 'work_period_start' date, leading to a 'WARNING' status if the final certificate is pending, rather than a 'FAIL' due to the absence of the final A1 certificate itself.**\n2. **Check validity against determined validation date:** Compare ALL expiry dates and work periods against the *determined validation date*.\n2a. For Romanian identity documents, extract the date of birth from the CNP (Cod Numeric Personal).\nThe CNP format is: S YY MM DD XXXXX C, where:\nS indicates gender and century (1 or 2 = born 1900–1999, 5 or 6 = born 2000–2099; odd = male, even = female),\nYYMMDD is the date of birth.\nFor example, a CNP of 1990124046252 represents a birth date of 1999-01-24.\nUse this to validate birth date consistency across documents and to calculate age as of the determined validation date.\n3. **No grace periods:** Documents must be valid on the exact *determined validation date* (for expiry) or their submission/issue date must be on or before the *determined validation date*.\n4. **Work authorization current:** A1/social security work period must include or extend beyond *determined validation date* OR its formal validity starts after the determined validation date but is adequately submitted/issued.\n5. **Safety certification current:** Safety certificate must not be expired relative to the *determined validation date*.\n6. **Identity document current:** Passport/ID must not be expired relative to the *determined validation date*.\n\n## **OUTPUT FORMAT:**\n\n```json\n{\n  \"validation_summary\": {\n    \"overall_status\": \"PASS/WARNING/FAIL\",\n    \"documents_validated\": [\"[Document Type 1]\", \"[Document Type 2]\", \"[Document Type 3]\", \"[Document Type 4]\"],\n    \"validation_date\": \"[determined validation date]\",\n    \"worker_nationality\": \"[nationality]\",\n    \"destination_country\": \"[work destination]\"\n  },\n  \"mandatory_documents_check\": {\n    \"social_security_document_present\": \"YES/NO\",\n    \"identity_document_present\": \"YES/NO\", \n    \"work_notification_present\": \"YES/NO\",\n    \"safety_certificate_present\": \"YES/NO\",\n    \"all_mandatory_present\": \"YES/NO\"\n  },\n  \"personal_data_comparison\": {\n    \"name\": {\n      \"social_security_doc\": \"[name from social security doc]\",\n      \"identity_doc\": \"[name from identity doc]\", \n      \"work_notification\": \"[name from work notification]\",\n      \"safety_certificate\": \"[name from safety cert]\",\n      \"status\": \"MATCH/MISMATCH\",\n      \"issues\": \"[any issues found]\"\n    },\n    \"birth_date\": {\n      \"social_security_doc\": \"[date]\",\n      \"identity_doc\": \"[date]\",\n      \"safety_certificate\": \"[date if available]\",\n      \"status\": \"MATCH/MISMATCH\"\n    },\n    \"personal_identifier\": {\n      \"social_security_doc\": \"[personal number/code/BSN/PESEL/etc]\", \n      \"identity_doc\": \"[personal number/code/BSN/PESEL/etc]\",\n      \"type\": \"[BSN/PESEL/Personal Code/Social Security Number/etc]\",\n      \"status\": \"MATCH/MISMATCH\"\n    },\n    \"nationality\": {\n      \"social_security_doc\": \"[nationality]\",\n      \"identity_doc\": \"[nationality]\", \n      \"status\": \"MATCH/MISMATCH\"\n    }\n  },\n  \"document_validity_check\": {\n    \"identity_document_expiry\": \"[date]\",\n    \"safety_certificate_expiry\": \"[date]\",\n    \"work_period_end\": \"[date]\",\n    \"validity_status\": \"VALID/EXPIRED/EXPIRING_SOON\"\n  },\n  \"original_document_details\": {\n    \"social_security_data\": {\n      \"document_type\": \"[A1/A28/National equivalent]\",\n      \"worker_name\": \"[full name]\",\n      \"birth_date\": \"[date]\",\n      \"personal_identifier\": \"[BSN/PESEL/Personal Code/etc]\",\n      \"nationality\": \"[nationality]\",\n      \"work_period_start\": \"[start date]\",\n      \"work_period_end\": \"[end date]\",\n      \"sending_company\": \"[company name]\",\n      \"receiving_companies\": [\"[list of companies]\"],\n      \"director_manager\": \"[director/manager name]\",\n      \"profession\": \"[job title]\",\n      \"issuing_country\": \"[country]\",\n      \"additional_fields\": {\n        \"stamp_present\": true,\n        \"stamp_confidence\": 0.9,\n        \"signature_present\": true,\n        \"signature_confidence\": 0.7,\n        \"luik_3_2_checked\": true,\n        \"luik_4_1_1_checked\": false,\n        \"[any other fields found]\": \"[values]\"\n      }\n    },\n    \"identity_document_data\": {\n      \"document_type\": \"[ID Card/Passport/National ID]\",\n      \"surname\": \"[surname]\",\n      \"given_names\": \"[given names]\",\n      \"birth_date\": \"[date]\",\n      \"personal_identifier\": \"[document number/BSN/PESEL/etc]\",\n      \"nationality\": \"[nationality]\",\n      \"document_number\": \"[ID/passport number]\",\n      \"expiry_date\": \"[expiry date]\",\n      \"gender\": \"[M/F]\",\n      \"issuing_country\": \"[country]\",\n      \"issuing_authority\": \"[authority]\",\n      \"additional_fields\": {\n        \"stamp_present\": true,\n        \"stamp_confidence\": 0.9,\n        \"signature_present\": true,\n        \"signature_confidence\": 0.9,\n        \"[any other fields found]\": \"[values]\"\n      }\n    },\n    \"work_notification_data\": {\n      \"document_type\": \"[Limosa/A1/National work notification]\",\n      \"employee_name\": \"[name]\",\n      \"work_period_start\": \"[start date]\",\n      \"work_period_end\": \"[end date]\", \n      \"employer_name\": \"[employer]\",\n      \"employer_address\": \"[address]\",\n      \"work_location\": \"[work location]\",\n      \"sector\": \"[work sector]\",\n      \"notification_country\": \"[country]\",\n      \"employee_identification\": \"[various ID numbers]\",\n      \"additional_fields\": {\n        \"stamp_present\": false,\n        \"stamp_confidence\": 0.0,\n        \"signature_present\": false,\n        \"signature_confidence\": 0.0,\n        \"[any other fields found]\": \"[values]\"\n      }\n    },\n    \"safety_certificate_data\": {\n      \"document_type\": \"[VCA/DGUV/National safety certificate]\",\n      \"holder_name\": \"[name]\",\n      \"birth_date\": \"[date]\",\n      \"certificate_number\": \"[certificate number]\",\n      \"certificate_type\": \"[specific type/level]\",\n      \"expiry_date\": \"[expiry date]\",\n      \"issue_place\": \"[issuing location]\",\n      \"issuing_country\": \"[country]\",\n      \"exam_language\": \"[language]\",\n      \"validity_scope\": \"[where valid]\",\n      \"additional_fields\": {\n        \"stamp_present\": true,\n        \"stamp_confidence\": 0.9,\n        \"signature_present\": true,\n        \"signature_confidence\": 0.7,\n        \"[any other fields found]\": \"[values]\"\n      }\n    }\n  },\n  \"cross_document_consistency\": {\n    \"work_periods_align\": \"YES/NO/PARTIAL\",\n    \"employer_consistency\": \"YES/NO\", \n    \"location_consistency\": \"YES/NO\",\n    \"eu_regulation_compliance\": \"YES/NO/PARTIAL\"\n  },\n  \"flags_and_warnings\": [\n    {\n      \"type\": \"WARNING/ERROR/CRITICAL\",\n      \"field\": \"[field name]\",\n      \"message\": \"[description of issue]\",\n      \"country_specific\": \"[if country-specific issue]\"\n    }\n  ],\n  \"recommendations\": [\n    \"[list of recommended actions]\"\n  ]\n}\nINSTRUCTIONS:\nFIRST: Determine the 'validation_date':\n\nIf the user explicitly provides a 'validation_date' in their input (e.g., \"Validate as of YYYY-MM-DD\"), use that date.\n\nOtherwise, the AI must infer the 'validation_date' as the earliest 'notification sent on' date (e.g., Limosa 'Melding verstuurd op', A1 application date/submission date, or similar formal issue date) found across all provided work authorization related documents. This date represents when the formal process began.\n\nIf no such 'notification sent on' or 'issue date' can be inferred, then use the earliest 'work_period_start' date from either the A1/Social Security Certificate or the Work Notification (Limosa/National equivalent) across all provided documents.\n\nIf no suitable date can be inferred from the documents, the AI should use the current actual date as the 'validation_date'.\n\nCrucially, if an A1 certificate application is provided and is signed, the AI must consider the worker eligible to commence work from its stated 'work_period_start' date, leading to a 'WARNING' status if the final certificate is pending, rather than a 'FAIL' due to the absence of the final A1 certificate itself.\n\nSECOND: Immediately check ALL expiry dates and work periods against the determined 'validation_date' AND the specific document's 'work_period_start' if it's in the future.\n\nAdapt field extraction based on country-specific formats\n\nCheck if all 4 mandatory document TYPES are present (regardless of exact names)\n\nVERIFY ALL DOCUMENTS ARE CURRENTLY VALID relative to the determined 'validation_date'. This means the document's expiry must be after 'validation_date', and for documents with a 'notification sent on' or 'issue date', this date must be on or before 'validation_date'. NO TOLERANCE FOR EXPIRED DOCUMENTS.\n\nEXTRACT AND PRESERVE ALL DETAILS from each document, including country-specific fields.\n\nCompare identical data across documents accounting for format differences.\n\nCheck EU work authorization validity and compliance. Specifically, verify if a signed application for an A1 certificate is provided. If so, and if this condition permits the worker to legally commence work according to EU or national regulations (which the AI must verify), issue a 'WARNING' status instead of a 'FAIL' for the social security document, if the final A1 certificate is not yet issued.\n\nFlag country-specific compliance issues.\n\nProvide clear PASS/WARNING/FAIL status.\n\nInformation regarding signatures or stamps must be returned/included with validation_date - this information is included in the accompanying data that I am providing. Additionally, information about checked boxes (particularly Luik 3.2 and Luik 4.1.1 in A1 forms) must also be returned in true/false format: return true only if the checkbox is actually checked/marked in the document, return false if the checkbox is not checked or not found. Do not interpret or modify any information about stamps, signatures, or checkboxes - return exactly what is present in the original documents.\n\nCRITICAL ADAPTATIONS:\nPersonal Identifiers: BSN (NL), PESEL (PL), Personal Code (LT), Social Security Number (various)\n\nDocument Names: A1/A28 (EU), Limosa (BE/NL), National work permits\n\nSafety Certificates: VCA (NL/BE), DGUV (DE), National equivalents\n\nName Formats: Account for different European naming conventions\n\nDate Formats: DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD variations\n\nEUROPEAN-SPECIFIC CHECKS:\nEU regulation 883/2004 compliance for social security coordination\n\nPosting worker directive compliance\n\nCountry-specific work notification requirements\n\nProfessional qualification recognition (where applicable)\n\nLanguage requirements for safety certificates\n\nIMPORTANT: - This system must work for workers from ANY EU country working in ANY other EU country.\nExtract ALL available information regardless of country-specific formatting.\n\nPreserve original field names alongside standardized interpretations.\n\nNO EXCEPTIONS FOR EXPIRED DOCUMENTS - ALL MUST BE CURRENTLY VALID relative to the determined 'validation_date'.\n\nZERO TOLERANCE FOR EXPIRED WORK AUTHORIZATION (unless a valid, signed A1 application is confirmed to permit work commencement, leading to a 'WARNING' as per instruction 8).\n\nA document's 'work_period_start' being in the future relative to the 'validation_date' is acceptable IF the document's 'notification sent on' or 'issue date' is on or before the 'validation_date', indicating a valid future authorization.\n\nValidation_date cannot possibly be 2024; it can only be today's date. Any attempt to give it a different date is an error on your part and must be corrected before submitting the answer.",
          "passthroughBinaryImages": "={{ true }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        -1664,
        1600
      ],
      "id": "61973d87-789a-464e-a4da-867831d46937",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "c231ae42-f532-4058-b1c8-eaa599f26d2c",
              "leftValue": "={{ $json.mimeType }}",
              "rightValue": "image/png",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "ceacc451-4c5f-473b-90bf-b0b0a90ffea9",
              "leftValue": "={{ $json.mimeType }}",
              "rightValue": "image/jpg",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1872,
        1328
      ],
      "id": "961013cb-a01a-4009-8979-825479c65220",
      "name": "If1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1408,
        1328
      ],
      "id": "2e3d25c0-1401-4d5b-9d7d-4f32aff3b1b3",
      "name": "Merge"
    },
    {
      "parameters": {
        "fromEmail": "ai@go-knowledge.nl",
        "toEmail": "={{ $('On form submission').item.json.Mail }}",
        "subject": "=AI validation check : {{ $json.worker_name }}",
        "html": "={{ $json.html_report }}",
        "options": {
          "appendAttribution": false,
          "attachments": "={{ Object.keys($binary).join(\",\") }}"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        -1856,
        1952
      ],
      "id": "45ffe97d-8d91-4b8d-9755-6f413fa0a9b9",
      "name": "Send email",
      "webhookId": "1f7e2d12-8eed-459f-8d0e-b8c4d82b0d34",
      "notesInFlow": true,
      "alwaysOutputData": true,
      "credentials": {
        "smtp": {
          "id": "yG4Ihfi7vhKZzG49",
          "name": "ai@go-knowledge"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// JSON data ophalen uit de vorige node\nconst jsonData = $input.first().json;\n\n// ===== CONSTANTEN =====\nconst DOCUMENT_TYPE_MAPPINGS = {\n    'Identity Document': 'ID Card / Passport',\n    'Passport': 'ID Card / Passport', \n    'Social Security Document': 'A1',\n    'Social Security': 'A1',\n    'Socialsecurity': 'A1',\n    'Work Notification': 'Limosa',\n    'Safety Certificate': 'VCA / SCC'\n};\n\nconst DOCUMENT_ORDER = ['ID Card / Passport', 'Limosa', 'VCA / SCC', 'A1'];\n\nconst PRIORITY_FIELDS = [\n    'document_type', 'certificate_type', 'document_number', 'certificate_number',\n    'given_names', 'surname', 'worker_name', 'holder_name', 'employee_name',\n    'birth_date', 'nationality', 'gender', 'personal_identifier',\n    'work_period_start', 'work_period_end', 'expiry_date', 'issue_date',\n    'employer_name', 'sending_company', 'work_location', 'sector',\n    'issuing_country', 'issuing_authority', 'notification_country', \n    'firm_issuing', 'issue_place', 'basis_of_vol'\n];\n\nconst DOCUMENT_STATUS_FIELDS = [\n    'social_security_document_present', 'identity_document_present', \n    'work_notification_present', 'safety_certificate_present', \n    'professional_certificate_present', 'training_certificate_present',\n    'medical_certificate_present', 'all_mandatory_present'\n];\n\nconst CONSISTENCY_FIELDS = ['name', 'birth_date', 'personal_identifier', 'nationality'];\n\nconst EXCEL_STYLES = {\n    Header: { backgroundColor: '#D9E1F2', bold: true },\n    Pass: { backgroundColor: '#C6EFCE' },\n    Fail: { backgroundColor: '#FFC7CE' },\n    Warn: { backgroundColor: '#FFEB9C' },\n    Critical: { backgroundColor: '#FF6B6B', bold: true },\n    Default: {}\n};\n\n// ===== UTILITY FUNCTIES =====\n\n/**\n * Helper functie om veilig waarden uit nested objecten te halen\n * @param {Object} obj - Het object om te doorzoeken\n * @param {string} path - Het pad naar de gewenste waarde (bijv. 'a.b.c')\n * @param {*} defaultValue - De standaardwaarde als de waarde niet gevonden wordt\n * @returns {*} De gevonden waarde of de standaardwaarde\n */\nfunction getValue(obj, path, defaultValue = 'N/A') {\n    try {\n        if (!obj || typeof obj !== 'object') return defaultValue;\n        \n        const value = path.split('.').reduce((acc, key) => {\n            return (acc && typeof acc === 'object' && key in acc) ? acc[key] : undefined;\n        }, obj);\n        \n        return value !== undefined && value !== null && value !== '' ? value : defaultValue;\n    } catch (error) {\n        console.warn(`Error accessing path ${path}:`, error.message);\n        return defaultValue;\n    }\n}\n\n/**\n * Zoekt door alle documenten naar een specifiek veld\n * @param {Array} documents - Array van documenten om te doorzoeken\n * @param {Array} fieldNames - Array van veldnamen om naar te zoeken\n * @returns {*} De eerste gevonden waarde of 'N/A'\n */\nfunction findInAllDocuments(documents, fieldNames) {\n    if (!Array.isArray(documents) || !Array.isArray(fieldNames)) return 'N/A';\n    \n    for (const fieldName of fieldNames) {\n        for (const doc of documents) {\n            const value = doc?.[fieldName];\n            if (value && value !== 'N/A' && value !== '') {\n                return value;\n            }\n        }\n    }\n    return 'N/A';\n}\n\n/**\n * Escapet speciale karakters in een string om het veilig te gebruiken in XML\n * @param {*} unsafe - De waarde om te escapen\n * @returns {string} De geëscapete string\n */\nfunction escapeXml(unsafe) {\n    if (unsafe === null || unsafe === undefined) return '';\n    \n    return String(unsafe)\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n\n/**\n * Normaliseert documenttype namen volgens de mapping\n * @param {string} categoryName - De originele categorienaam\n * @returns {string} De genormaliseerde naam\n */\nfunction normalizeDocumentType(categoryName) {\n    // Exacte matches eerst proberen\n    if (DOCUMENT_TYPE_MAPPINGS[categoryName]) {\n        return DOCUMENT_TYPE_MAPPINGS[categoryName];\n    }\n    \n    // Daarna partial matches\n    for (const [key, value] of Object.entries(DOCUMENT_TYPE_MAPPINGS)) {\n        if (categoryName.includes(key)) {\n            return value;\n        }\n    }\n    \n    // Speciale handling voor Social Security varianten\n    if (categoryName.toLowerCase().includes('social security') || \n        categoryName.toLowerCase().includes('socialsecurity')) {\n        return 'A1';\n    }\n    \n    return categoryName;\n}\n\n/**\n * Bepaalt de Excel style op basis van de waarde\n * @param {string} value - De waarde om te controleren\n * @returns {string} De style ID\n */\nfunction getExcelStyleForValue(value) {\n    const valStr = String(value).toUpperCase();\n    \n    if (valStr.includes('CRITICAL')) return 'Critical';\n    if (valStr.includes('PASS') || valStr.includes('YES') || valStr.includes('MATCH') || \n        valStr === 'TRUE' || valStr.includes('VALID')) return 'Pass';\n    if (valStr.includes('FAIL') || valStr.includes('NO') || valStr.includes('MISMATCH') || \n        valStr === 'FALSE') return 'Fail';\n    if (valStr.includes('WARNING') || valStr.includes('REVIEW') || \n        valStr.includes('UNKNOWN') || valStr.includes('ERROR')) return 'Warn';\n    \n    return 'Default';\n}\n\n/**\n * Formatteert een veldnaam voor weergave\n * @param {string} fieldName - De originele veldnaam\n * @returns {string} De geformatteerde naam\n */\nfunction formatDisplayName(fieldName) {\n    return fieldName\n        .replace(/_/g, ' ')\n        .replace(/\\b\\w/g, l => l.toUpperCase());\n}\n\n// ===== DOCUMENT PROCESSING FUNCTIES =====\n\n/**\n * Verwerkt een enkel document en extraheert alle relevante velden\n * @param {Object} doc - Het document object\n * @param {string} prefix - De prefix voor de veldnamen\n * @returns {Object} Object met alle geëxtraheerde velden\n */\nfunction processDocument(doc, prefix) {\n    if (!doc || typeof doc !== 'object' || Object.keys(doc).length === 0) {\n        return {};\n    }\n\n    const processedDoc = {};\n\n    // Verwerk priority fields eerst\n    for (const field of PRIORITY_FIELDS) {\n        const value = doc[field];\n        if (value !== undefined && value !== null && value !== '') {\n            const displayName = formatDisplayName(field);\n            processedDoc[`${prefix}_${displayName}`] = value;\n        }\n    }\n\n    // Verwerk overige velden\n    for (const [field, value] of Object.entries(doc)) {\n        if (PRIORITY_FIELDS.includes(field) || field === 'additional_fields' || \n            value === undefined || value === null || value === '') {\n            continue;\n        }\n\n        let displayValue = value;\n        if (Array.isArray(displayValue)) {\n            displayValue = displayValue.join(', ');\n        } else if (typeof displayValue === 'object') {\n            continue;\n        }\n\n        const displayName = formatDisplayName(field);\n        processedDoc[`${prefix}_${displayName}`] = displayValue;\n    }\n\n    // Verwerk boolean velden\n    ['stamp_present', 'signature_present'].forEach(field => {\n        if (doc[field] !== undefined) {\n            const displayName = formatDisplayName(field);\n            processedDoc[`${prefix}_${displayName}`] = doc[field] ? 'YES' : 'NO';\n        }\n    });\n\n    // Verwerk additional_fields\n    if (doc.additional_fields && typeof doc.additional_fields === 'object') {\n        for (const [field, value] of Object.entries(doc.additional_fields)) {\n            if (field.includes('_confidence') || value === undefined || \n                value === null || value === '') continue;\n\n            let displayValue = value;\n            if (typeof value === 'boolean') {\n                displayValue = value ? 'YES' : 'NO';\n            }\n\n            const displayName = formatDisplayName(field);\n            processedDoc[`${prefix}_${displayName}`] = displayValue;\n        }\n    }\n\n    return processedDoc;\n}\n\n/**\n * Verwerkt alle documenten en ordent ze volgens prioriteit\n * @param {Object} originalDocs - Het originalDocs object uit de data\n * @returns {Object} Geordende document data\n */\nfunction processAllDocuments(originalDocs) {\n    if (!originalDocs || typeof originalDocs !== 'object') {\n        return {};\n    }\n\n    const tempDocs = {};\n\n    // Verwerk alle document categorieën\n    for (const [category, docData] of Object.entries(originalDocs)) {\n        if (!docData) continue;\n\n        const documents = Array.isArray(docData) ? docData : [docData];\n        \n        documents.forEach((doc, index) => {\n            if (!doc || Object.keys(doc).length === 0) return;\n\n            let categoryName = category\n                .replace(/_data$/, '')\n                .replace(/_/g, ' ')\n                .replace(/\\b\\w/g, l => l.toUpperCase());\n\n            categoryName = normalizeDocumentType(categoryName);\n            \n            const prefix = documents.length > 1 ? `${categoryName}_${index + 1}` : categoryName;\n            tempDocs[prefix] = processDocument(doc, prefix);\n        });\n    }\n\n    // Orden documenten volgens prioriteit\n    const orderedData = {};\n    \n    // Voeg documenten toe in specifieke volgorde\n    for (const docType of DOCUMENT_ORDER) {\n        const matchingKeys = Object.keys(tempDocs).filter(key => key.includes(docType));\n        matchingKeys.forEach(key => {\n            Object.assign(orderedData, tempDocs[key]);\n        });\n    }\n\n    // Voeg overige documenten toe\n    Object.keys(tempDocs).forEach(key => {\n        if (!DOCUMENT_ORDER.some(docType => key.includes(docType))) {\n            Object.assign(orderedData, tempDocs[key]);\n        }\n    });\n\n    return orderedData;\n}\n\n/**\n * Extraheert algemene validatie data\n * @param {Object} data - De volledige data\n * @param {Object} report - Het report object\n * @param {Object} validation - Het validation summary object\n * @param {Array} allDocuments - Array van alle documenten\n * @returns {Object} Algemene validatie data\n */\nfunction extractGeneralData(data, report, validation, allDocuments) {\n    const generalData = {};\n    \n    // Basis informatie\n    generalData['Decision'] = data.decision || 'UNKNOWN';\n    generalData['Overall_Status'] = data.overall_status || validation.overall_status || 'UNKNOWN';\n    generalData['Validation_Date'] = validation.validation_date || new Date().toLocaleDateString('en-US');\n    generalData['Total_Documents_Processed'] = data.total_documents_processed || \n                                               validation.documents_processed || \n                                               allDocuments.length;\n\n    // Mandatory documents check\n    const mandatoryDocs = report.mandatory_documents_check || {};\n    for (const field of DOCUMENT_STATUS_FIELDS) {\n        if (mandatoryDocs[field] !== undefined) {\n            let displayName = field.replace(/_present$/, '').replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n            \n            // Normaliseer de display naam\n            displayName = normalizeDocumentType(displayName);\n            \n            if (displayName === 'VCA / SCC') {\n                displayName = 'VCA/SCC';\n            }\n            \n            generalData[`${displayName}_Status`] = mandatoryDocs[field];\n        }\n    }\n\n    // Personal data comparison\n    const personalComparison = report.personal_data_comparison || {};\n    for (const field of CONSISTENCY_FIELDS) {\n        const fieldData = personalComparison[field];\n        if (fieldData?.status) {\n            const displayName = formatDisplayName(field);\n            generalData[`${displayName}_Consistency`] = fieldData.status;\n            if (fieldData.issues) {\n                generalData[`${displayName}_Issues`] = fieldData.issues;\n            }\n        }\n    }\n\n    // Cross document consistency\n    const crossConsistency = report.cross_document_consistency || {};\n    for (const [field, value] of Object.entries(crossConsistency)) {\n        if (value !== undefined) {\n            const displayName = formatDisplayName(field);\n            generalData[`Cross_${displayName}`] = value;\n        }\n    }\n\n    // Document validity check\n    const docValidity = report.document_validity_check || {};\n    for (const [field, value] of Object.entries(docValidity)) {\n        if (value !== undefined && value !== 'N/A') {\n            const displayName = formatDisplayName(field);\n            generalData[`Validity_${displayName}`] = value;\n        }\n    }\n\n    return generalData;\n}\n\n/**\n * Extraheert flags en warnings data\n * @param {Object} report - Het report object\n * @param {Object} data - De volledige data\n * @returns {Object} Flags en warnings data\n */\nfunction extractFlagsAndWarnings(report, data) {\n    const flags = report.flags_and_warnings || data.full_validation_report?.flags_and_warnings || [];\n    const flagsData = {};\n    \n    // Totalen\n    flagsData['Total_Issues'] = flags.length;\n    flagsData['Critical_Issues_Count'] = flags.filter(f => f.type === 'CRITICAL').length;\n    flagsData['Error_Count'] = flags.filter(f => f.type === 'ERROR').length;\n    flagsData['Warning_Count'] = flags.filter(f => f.type === 'WARNING').length;\n    \n    // Details van eerste 5 issues\n    flags.slice(0, 5).forEach((flag, index) => {\n        const num = index + 1;\n        flagsData[`Issue_${num}_Type`] = flag.type;\n        flagsData[`Issue_${num}_Field`] = flag.field || 'N/A';\n        flagsData[`Issue_${num}_Message`] = flag.message;\n        \n        if (flag.weighted_severity) {\n            flagsData[`Issue_${num}_Severity`] = flag.weighted_severity;\n        }\n    });\n    \n    return flagsData;\n}\n\n/**\n * Extraheert recommendations data\n * @param {Object} report - Het report object\n * @param {Object} data - De volledige data\n * @returns {Object} Recommendations data\n */\nfunction extractRecommendations(report, data) {\n    const recommendations = report.recommendations || data.full_validation_report?.recommendations || [];\n    const recommendationsData = {};\n    \n    recommendationsData['Total_Recommendations'] = recommendations.length;\n    \n    recommendations.slice(0, 3).forEach((rec, index) => {\n        recommendationsData[`Recommendation_${index + 1}`] = rec;\n    });\n    \n    return recommendationsData;\n}\n\n/**\n * Extraheert metadata\n * @param {Object} validation - Het validation summary object\n * @returns {Object} Metadata\n */\nfunction extractMetadata(validation) {\n    const metadata = {};\n    \n    if (validation.destination_country) {\n        metadata['Destination_Country'] = validation.destination_country;\n    }\n    \n    return metadata;\n}\n\n/**\n * Hoofdfunctie om alle data uit het complexe JSON-object te extraheren\n * @param {Object} data - Het volledige data object\n * @returns {Object} Alle geëxtraheerde data in geordende vorm\n */\nfunction extractAllData(data) {\n    try {\n        // Veilig data structuren ophalen\n        const report = getValue(data, 'full_validation_report.individual_reports.0') || \n                      getValue(data, 'full_validation_report') || \n                      data;\n        \n        const validation = getValue(data, 'full_validation_report.validation_summary') || \n                          getValue(report, 'validation_summary') || \n                          {};\n        \n        const originalDocs = getValue(report, 'original_document_details') || {};\n\n        // Maak een platte lijst van alle documenten\n        const allDocuments = [];\n        for (const [category, docData] of Object.entries(originalDocs)) {\n            if (docData) {\n                const documents = Array.isArray(docData) ? docData : [docData];\n                documents.forEach(doc => {\n                    if (doc && typeof doc === 'object') {\n                        allDocuments.push({ category, ...doc });\n                    }\n                });\n            }\n        }\n\n        // Extraheer verschillende data secties\n        const generalData = extractGeneralData(data, report, validation, allDocuments);\n        const documentData = processAllDocuments(originalDocs);\n        const flagsData = extractFlagsAndWarnings(report, data);\n        const recommendationsData = extractRecommendations(report, data);\n        const metadata = extractMetadata(validation);\n\n        // Combineer alle data\n        return {\n            ...generalData,\n            ...documentData,\n            ...flagsData,\n            ...recommendationsData,\n            ...metadata\n        };\n        \n    } catch (error) {\n        console.error('Error extracting data:', error);\n        return {\n            'Error': 'Data extraction failed',\n            'Error_Message': error.message,\n            'Decision': 'ERROR',\n            'Overall_Status': 'PROCESSING_ERROR'\n        };\n    }\n}\n\n/**\n * Genereert Excel XML content\n * @param {Object} reportData - De report data\n * @param {string} workerName - De naam van de werker\n * @returns {string} Excel XML content\n */\nfunction generateExcelXML(reportData, workerName) {\n    const styles = Object.entries(EXCEL_STYLES).map(([id, style]) => {\n        const fontProps = style.bold ? ' ss:Bold=\"1\"' : '';\n        const interiorProps = style.backgroundColor ? \n            ` ss:Color=\"${style.backgroundColor}\" ss:Pattern=\"Solid\"` : '';\n        \n        return `  <Style ss:ID=\"${id}\">\n   <Font ss:Size=\"11\"${fontProps}/>\n   ${interiorProps ? `<Interior${interiorProps}/>` : ''}\n  </Style>`;\n    }).join('\\n');\n\n    const rows = Object.entries(reportData).map(([key, value]) => {\n        const styleID = getExcelStyleForValue(value);\n        const displayKey = key.replace(/_/g, ' ');\n        \n        return `    <Row>\n     <Cell ss:StyleID=\"Header\"><Data ss:Type=\"String\">${escapeXml(displayKey)}</Data></Cell>\n     <Cell ss:StyleID=\"${styleID}\"><Data ss:Type=\"String\">${escapeXml(String(value ?? ''))}</Data></Cell>\n    </Row>`;\n    }).join('\\n');\n\n    return `<?xml version=\"1.0\"?>\n<?mso-application progid=\"Excel.Sheet\"?>\n<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\n xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\">\n <DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\n  <Title>Complete Document Validation Report</Title>\n  <Subject>Worker: ${escapeXml(workerName)}</Subject>\n  <Created>${new Date().toISOString()}</Created>\n </DocumentProperties>\n <Styles>\n${styles}\n </Styles>\n <Worksheet ss:Name=\"Complete Validation Report\">\n  <Table>\n    <Column ss:StyleID=\"Header\" ss:AutoFitWidth=\"1\" ss:Width=\"200\"/>\n    <Column ss:AutoFitWidth=\"1\" ss:Width=\"300\"/>\n${rows}\n  </Table>\n </Worksheet>\n</Workbook>`;\n}\n\n// ===== HOOFDLOGICA =====\n\ntry {\n    // 1. Valideer input data\n    if (!jsonData) {\n        throw new Error('Missing JSON data');\n    }\n    \n    // Handle array input - neem het eerste element als het een array is\n    let processData = jsonData;\n    if (Array.isArray(jsonData)) {\n        if (jsonData.length === 0) {\n            throw new Error('Empty JSON array provided');\n        }\n        processData = jsonData[0];\n        console.log(`📋 Input is een array met ${jsonData.length} element(en), gebruik het eerste element`);\n    }\n    \n    if (!processData || typeof processData !== 'object') {\n        throw new Error('Invalid JSON data structure');\n    }\n\n    // 2. Extraheer alle data\n    const reportData = extractAllData(processData);\n\n    // 3. Genereer bestandsnaam\n    const workerName = findInAllDocuments([reportData], ['Worker_Name', 'worker_name', 'holder_name', 'employee_name']) || 'Unknown_Worker';\n    const cleanWorkerName = workerName.replace(/[^a-zA-Z0-9\\s-]/g, '').replace(/\\s+/g, '_');\n    const dateStr = new Date().toISOString().split('T')[0];\n    const fileName = `Complete_Validation_Report_${cleanWorkerName}_${dateStr}.xls`;\n\n    // 4. Genereer Excel XML\n    const excelXML = generateExcelXML(reportData, workerName);\n\n    // 5. Log resultaten\n    console.log(`✅ Excel-bestand succesvol gegenereerd voor: ${workerName}`);\n    console.log(`📊 Aantal datapunten geëxtraheerd: ${Object.keys(reportData).length}`);\n    console.log(`📁 Bestandsnaam: ${fileName}`);\n    console.log(`🎯 Beslissing: ${reportData.Decision}`);\n    console.log(`📈 Status: ${reportData.Overall_Status}`);\n\n    // 6. Return de resultaten\n    return {\n        json: {\n            ...jsonData,\n            excelGenerated: true,\n            excelFilename: fileName,\n            totalDataPoints: Object.keys(reportData).length,\n            reportSummary: {\n                decision: reportData.Decision,\n                status: reportData.Overall_Status,\n                criticalIssues: reportData.Critical_Issues_Count || 0,\n                totalDocuments: reportData.Total_Documents_Processed || 0,\n                processingTimestamp: new Date().toISOString()\n            }\n        },\n        binary: {\n            ...($input.first().binary || {}),\n            file: {\n                data: Buffer.from(excelXML, 'utf8').toString('base64'),\n                mimeType: 'application/vnd.ms-excel',\n                fileName: fileName\n            }\n        }\n    };\n\n} catch (error) {\n    console.error('❌ Kritieke fout bij Excel generatie:', error);\n    \n    // Return error informatie maar probeer toch door te gaan\n    return {\n        json: {\n            ...jsonData,\n            excelGenerated: false,\n            error: error.message,\n            errorTimestamp: new Date().toISOString()\n        },\n        binary: $input.first().binary || {}\n    };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        1632
      ],
      "id": "f41f2f69-d739-4a3d-92fc-349bb745e664",
      "name": "excel 3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://172.17.0.5:3000/forms/libreoffice/convert",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1632,
        1232
      ],
      "id": "51b4c3da-cc3d-4959-a8d8-1f7f264f60d1",
      "name": "HTTP Request1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [\n    {\n      \"parts\": [\n        {\n          \"text\": \"You will receive one or more official documents belonging to a single individual. These documents may include, but are not limited to:\\n\\n- Passports and ID cards (EU and non-EU)\\n- Residence permits, work permits, A1 forms\\n- Limosa declarations\\n- VCA, SVWOH, SCC or similar safety certificates\\n- Diplomas, training certificates, and professional qualifications\\n- Any document related to employment eligibility, education or legal stay in Belgium or the EU\\n\\nSome individuals are nationals of third countries (outside the EU/EEA/Switzerland) and will submit more than the typical number of documents. Handle all documents equally and return structured output per document.\\n\\nIf a document is spread over multiple pages (such as an A1 form), detect that the pages belong together based on layout, headers, document number, or visual consistency. In that case, return a single merged JSON object with all combined data and a concatenated raw_text field. Do not split multi-page documents into multiple objects.\\n\\nVisually inspect the entire document image for official stamps (ink or embossed) and handwritten signatures. These elements are crucial for document validity. Populate the `stamp_present` and `signature_present` fields accurately based on this visual check.\\n\\nAdditionally, carefully examine all documents for checked boxes or marked text fields, particularly in A1 forms where specific sections may be checked or marked to indicate selections, declarations, or confirmations. Pay special attention to whether Luik 3.2 and Luik 4.1.1 are checked/marked, as these are critical administrative indicators. Document these checked/marked areas as they contain important administrative information.\\n\\n**Information regarding signatures or stamps must be returned/included with validation_date and can be found in the accompanying data provided.**\\n\\nAt the top level of the response, return two additional fields:\\n\\n1. `person_check`: an object containing:\\n   - `same_person` (boolean): whether all documents likely belong to the same individual (≥70% name match).\\n   - `cross_document_name_match_score` (float): the average name similarity score between all documents (0.0–1.0).\\n   - `name_variants` (array): all unique detected full name variants across documents.\\n\\n2. `documents_check`: an object containing:\\n   - `required_documents` (array): based on nationality (EU/EEA/CH or third-country), list required document types.\\n   - `present_documents` (array): list of all detected document types.\\n   - `missing_required_documents` (array): required types that were not found.\\n   - `all_required_documents_present` (boolean): true if nothing is missing.\\n\\nThen return `documents` as a strict JSON array, where each document (or merged multi-page document) is one object.\\n\\nEach document must include the following structure:\\n\\n- document_type\\n- country_of_origin\\n- full_name\\n- date_of_birth (format: YYYY-MM-DD)\\n- document_number\\n- expiry_date\\n- certificate_id\\n- diploma_title\\n- employer_name\\n- employment_period (e.g. from-to dates)\\n- exam_date\\n- valid_until\\n- stamp_present: true or false\\n- stamp_confidence: float (0.0–1.0)\\n- signature_present: true or false\\n- signature_confidence: float (0.0–1.0)\\n- raw_text: the full OCR output, even if noisy or partial\\n\\nExample output:\\n\\n{\\n  \\\"person_check\\\": {\\n    \\\"same_person\\\": true,\\n    \\\"cross_document_name_match_score\\\": 0.81,\\n    \\\"name_variants\\\": [\\\"Nihad Aliyev\\\", \\\"ALIYEV Nihad\\\", \\\"N.A. Aliyev\\\"]\\n  },\\n  \\\"documents_check\\\": {\\n    \\\"required_documents\\\": [\\\"id_card\\\", \\\"a1_form\\\", \\\"limosa\\\"],\\n    \\\"present_documents\\\": [\\\"id_card\\\", \\\"a1_form\\\", \\\"limosa\\\", \\\"svwoh\\\"],\\n    \\\"missing_required_documents\\\": [],\\n    \\\"all_required_documents_present\\\": true\\n  },\\n  \\\"documents\\\": [\\n    {\\n      \\\"document_type\\\": \\\"id_card\\\",\\n      \\\"country_of_origin\\\": \\\"LTU\\\",\\n      \\\"full_name\\\": \\\"ALIYEV Nihad\\\",\\n      \\\"date_of_birth\\\": \\\"1995-01-31\\\",\\n      \\\"document_number\\\": \\\"760304769\\\",\\n      \\\"expiry_date\\\": \\\"2025-11-06\\\",\\n      \\\"certificate_id\\\": null,\\n      \\\"diploma_title\\\": null,\\n      \\\"employer_name\\\": null,\\n      \\\"employment_period\\\": null,\\n      \\\"exam_date\\\": null,\\n      \\\"valid_until\\\": null,\\n      \\\"stamp_present\\\": false,\\n      \\\"stamp_confidence\\\": 0.0,\\n      \\\"signature_present\\\": true,\\n      \\\"signature_confidence\\\": 0.75,\\n      \\\"raw_text\\\": \\\"...\\\"\\n    }\\n    // More documents here...\\n  ]\\n}\\n\\nOnly return valid JSON. Do not include explanations, markdown, bullet points, or formatting. Return pure machine-readable JSON output only. Combine the documents that are the same, i.e. A1, together.\\n\\nThe `date_of_birth` is a critical field for ID cards and passports. If this field is not explicitly labeled or readable, actively search for a national identification number (e.g., Romanian CNP/CRP, Polish PESEL, etc.). These numbers often embed the date of birth near the beginning in a `YYMMDD` format.\\n* **Logic:** You must derive the date of birth from this number. The century (`19xx` vs `20xx`) is often indicated by a preceding digit.\\n* **Example:** A Romanian CRP number starting with `1810421` indicates a male (`1`) born on April 21, 1981 (`810421`). This must be normalized to `1981-04-21`. A number starting with `5` or `6` often indicates a birth year in the 2000s (e.g., `501...` for `2001`).\\n* **Task:** Always extract, interpret, and normalize this date into the `YYYY-MM-DD` format and populate the `date_of_birth` field. Do not leave this field null if the information can be derived. Check all documents extra for signatures and stamps!\"\n        },\n        {\n          \"inline_data\": {\n            \"mime_type\": \"application/pdf\",\n            \"data\": \"{{ $json.data }}\"\n          }\n        }\n      ]\n    }\n  ]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -592,
        1600
      ],
      "id": "c005abbf-ef0e-42a1-9e3d-4c319fb45aaa",
      "name": "Extract PDF Content Using Gemini Vision1",
      "credentials": {
        "httpQueryAuth": {
          "id": "t6Npfn3CB5NrgzCP",
          "name": "Query Auth account"
        }
      }
    }
  ],
  "connections": {
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "json set": {
      "main": [
        [
          {
            "node": "excel 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "On form submission": {
      "main": [
        [
          {
            "node": "Extract Attachments2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract PDF Content Using Gemini Vision": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform to base64": {
      "main": [
        [
          {
            "node": "Extract PDF Content Using Gemini Vision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "mail template": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Send email",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Email1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Attachments2": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "json set",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Transform to base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "excel 3": {
      "main": [
        [
          {
            "node": "mail template",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "Europe/Amsterdam",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "zM9trOH14KTomHbp"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "87d33d02-726c-487a-b9a4-5b7c5f917043",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-07-22T08:20:42.023Z",
      "updatedAt": "2025-07-22T08:20:42.023Z",
      "role": "workflow:owner",
      "workflowId": "zM9trOH14KTomHbp",
      "projectId": "GRYQdjzbr9zYZfKu"
    }
  ],
  "tags": [
    {
      "createdAt": "2025-09-01T13:28:32.194Z",
      "updatedAt": "2025-09-01T13:28:32.194Z",
      "id": "Jh4zLGg3JIJSdDBk",
      "name": "Google Gemini pro"
    }
  ]
}